# Chapter 09 - Create handlers for SOAP web services
* The handler framework allows interception of a message at various points it its transmission
* Handlers are simple Java classes that implement a handler contract and can be associated with web service endpoints and web service clients
* With outgoing messages, handlers are invoked before the message is sent to the wire
* With incoming messages, handlers are invoked before the receiving application receives the message
* The same handler implementation is used for both incoming and outgoing messages

* JAX-WS provides two levels of handlers:
    * Logical handlers deal with the payload level of the message. Logical handlers can be used for building non-functional behavior, such as loggin and caching, that is common across protocols
    * Protocol handlers deal with protocol information, such as SOAP headers

* **Logical handlers**
* The *close* method is to clean up any resources that handler invocation might have consumed
* The *handleFault* method is invoked if an error condition occurs
* The *handleMessage* method (and *handleFault*) return a *boolean*:
    * Returning *true* tells JAX-WS runtime that processing should move to the next handler in the chain
    * Returning *false* tells JAX-WS runtime that processing of the hanlder chain should en

* The parameter of *handleMessage* is a *LogicalMessageContext*
* A useful property is the *MESSAGE_OUTBOUND_PROPERTY* defined on the *MessageContext* interface, which gives you the direction of the message

* **Protocol handlers**
* The primary reason for writing a SOAP handler is to manipulate SOAP headers
* The *getHeaders* method returns the set of the header names that the handler understands
* The JAX-WS runtime calls this method to determine whether the handler can process SOAP headers that must be understood (as indicated by the SOAP *mustUnderstand* attribute)
* By using *SOAPMessage*, you can programmatically examine or modify SOAP message headers

## 9.1 Configure SOAP and logical handlers on the server side

### 9.1.1 Use @HandlerChain annotation
* With JAX-WS, you can declaratively specify a web service handler chain by using the *@javax.jws.HandlerChain* annotation

### 9.1.2 Use deployment descriptors
* The *webservices.xml* deployment descriptors file was introducted by the first version of JSR-109 to defined the set of web services that are to be deployed in a container
* However, with JAX-WS, the use of *webservices.xml* is optional since the annotations can be used to specify most of the information specified in this deployment descriptor
* When you are deploying JAX-WS web services, the only reason you should use *webservices.xml* is to override or augment the annotation member attributes - or when you do not want to use annotations because you don't want to modify the Java source code

* When using the *webservies.xml*, it is important to understand how the *port-component* names match up with the annotations
* In other words, *port-component-names* related to *@WebService.name*; *wsdl-service* relates to *@WebService.serviceName*; *wsdl-port* relates to *@WebService.portName*; and *service-endpoint-interface* relates to *@WebService.endpointInterface*

## 9.2 Configure SOAP and Logical handlers on the client side

### 9.2.1 Use deployment descriptors
* The declarative configuration works for proxy clients only and works in the same way as for the endpoint example
* That it, you simply add an annotation to the client-side generated SEI, which enables the handlers for all proxies and dispatch clients that are generated by using any ports on the SEI

### 9.2.2 Use programmatic API
* The programmatic configuration works for all JAX-WS services, generated service interfaces, and the generic service
* Handlers are added to the client-side service by using the following method:
    * Service.setHanlderResolver(HandlerResolver handlerResolver);

* An advantage of the programmatic approach is that you are not required to change generated code
