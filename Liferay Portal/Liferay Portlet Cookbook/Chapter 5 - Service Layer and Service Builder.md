# Chapter 5 - Service Layer and Service Builder
* This Chapter Covers:
    * Service Builder Tools
    * Generating our first Service Layer
    * Invoking the Service Layer API
    * Pulling Data - Use another API
    * Avoiding multiple submits
    * Separating the Business Logic
    * Service Layer of Portal Source
    * Sharing a custom service layer
    * Caching to improve performance
    * Explanation for *service.xml* DTD

## 5.1 Service Builder Explained
* Service Builder is a *Model-Driven* 
* You never have to touch or modify any of the classes it generates

## 5.2 Generating our first Service Layer

### 5.2.1 New Liferay Service Builder
* See code

### 5.2.2 Files Generated by Service Builder
* The following files (*classes*/*interface*) are generated under **WEB-INF/service**:
    * Model
    * Persistence
    * Service
    * Messaging
    * Exception
* The following files, all classes, are generated under **WEB-INF/src**:
    * Model
    * Service
* Spring and Hibernate related configuration files go under **src/META-INF**    
* Folder **WEB-INF/sql** contains the DDL statements to be run against the database to create the tables, indices and sequences for the entities
* The entire contents of **WEB-INF/service** get packaged as a JAR file, and get into the **WEB-INF/lib** folder
* Out of the generated files, one file is common of all entities **ClpSerializer.java**, Class Loader Proxy

### 5.2.3 Files to be checked in to SVN
* 2 files need to check in: *service.xml* and *LocalServiceImpl.java*
* The table name is prefixed with the "Namespace" that you give in *service.xml*
* You can optionally disable this auto-prefix by specifying *auto-namespace-tables=false* attribute for *service-builder* tag of the *service.xml*

## 5.3 Invoking the Service Layer API
* There are four distinct steps in this code:
    * Instantiate an empty object of type **LMSBookImpl**
    * Generate a unique primary key to be set for that object
    * Set the reset of fields for this object
    * Call the Service Layer API to persist the object to the database

### 5.3.1 Making our code as a new method
* Extract code to new method
     
### 5.3.2 Auto-generating the primary key
* Liferay provides a service - **CounterService**
* Use database that have the capability of natively auto-generating a primary key:
    * *Increased performance*
    * *Reduced code*

## 5.4 Pulling Data - Use another API
* Use *LMSBookLocalServiceUtil* to retrieve the records from the database

## 5.5 Avoiding Multiple Submits

### 5.5.1 Declarative way
* Open *liferay-portlet.xml* and insert after *icon*: *action-url-redirect* set to true

### 5.5.2 Programmatic way
* See code

### 5.5.3 Redirecting to any other page
* See code

### 5.5.4 Attributes of actionRequest
* Each of those attributes provides lot of information about the Portlet itself and the context in which it is running, the Portlet Container
 
 ## 5.6 Separating the Business Logic
 * See code
 
 ### 5.6.1 Never write business logic in Portlet Class
 * Write the business logic API's in the entity's **ServiceImpl** classes has some big benefits:
    * Complete separation of the business logic
    * Re-usability of invocation from multiple places
    * Auto-inject of dependency classes through Spring's DI
    * Automatic handling of transaction
    * The API's can be wrapped by a remote service and exposed outside of the application
    * Easy permission checking and security checks before performing an operation

### 5.6.2 Objects injected by default
* Add *reference* tag in **service.xml**

## 5.7 Service Layer of Portal Source

## 5.8 Sharing a custom service layer
* Copy the generated **service.jar** file from its **WEB-INF/lib** and paste into the equivalent **lib** folders of other plugins that want to use it
* Create a dummy Portlet and create the service layer inside it. Copy the jar file and paste into the global **lib/ext**
* Any method that is defined in to DTO class EntityServiceImpl.java can ONLY return an object belonging to the following types:
    * An instance of the same entity itself that the "service.xml" has defined
    * An list of entities of the above type
    * A primitive value or it's Wrapper class equivalent

## 5.9 Caching to improve performance
* The caching system of Liferay spans across all three layers - front-end (*portlet*), middleware (*service layer*) and back-end (*persistence*)
* Frontend:
    * Page HTML Cache (CacheFilter)
    * Portlet Caching (UI and Resources)
    * CSS & JS Cache (Minified & Bundled)
* Middleware:
    * Multi VM Pool (Cluster aware)
    * Single VM Pool
* Backend:
    * ServiceBuilder Finder Cache & Entity Cache
    * Hibernate Caching (L1 & L2)

## 5.10 "service.xml" DTD Explained
* See file liferay-service-builder_6_0_0.dtd
