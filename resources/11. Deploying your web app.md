## 11. Deploying your web app
* Objectives - Web Application Deployment

## The Joy of Deployment
* Where do YOU put things in the web app?
* Where will the CONTAINER look for things in the web app?
* How does the CLIENT request things in the web app?

## What goes where in a web app
* To deploy a web app successfully, you MUST follow this structure
    * WEB-INF must be immediately under the application context
    * The package structure for the classes must be immediately inside "classes"
    * The "lib" directory must be immediately inside "WEB-INF", and the JAR file must be immediately inside "lib"
    * The "META-INF" must be immediately inside the JAR
    * TLD files in a JAR must be somewhere under "META-INF"
    * TLDs that are NOT in a JAR must be somewhere under "WEB-INF"
    * Tag Files (.tag or .tagx) must be *somewhere* under "WEB-INF/tags" ("META-INF/tags")
* The directory structure of a web app is intense. And everything has to be in exactly the right place. Moving a web app can hurt

## WAR files
* A WAR file is simply a snapshot of your web app structure, in a nice portable, compressed form
* In Tomcat, the name of the WAR file becomes the web app name!
* In a WAR file, you can declare library dependencies in the META-INF/MANIFEST.MF file, which gives you a *deploy-time* check for whether the Container can find the packages and classes our app depends on
* Don't be fooled by questions about WAR files... the rules don't change!

## What a deployed WAR file looks like
* You will probably *never* put anything into the META-INF directory yourself, so you'll probably never care whether your app is deployed as a WAR unless you do need to specify library dependencies in the MANIFEST.MF file

## Making static content and JSPs directly accessible
* Nothing under WEB-INF or WEB-INF can be directly accessed
* Clients can directly access static content and JSPs at the web app root level or in subdirectories
* If the server gets a client request for anything under WEB-INF or META-INF, the Container MUST response with a 404 NOT FOUND error!

## How servlet mapping REALLY works
* Every servlet mapping has two parts - the <servlet> element and the <servlet-mapping> element
* The <servlet> defines a <servlet-name> and <servlet-class>
* The <servlet-mapping> defines the URL pattern that maps to a <servlet-name> defined somewhere else in the DD

## Servlet mappings can be "fake"
* The virtual/logical structure exists simple because you SAY it exists!
* The URL patterns in the DD don't map to anything except other <servlet-name> elements in the DD
* The <servlet-name> elements are the key to servlet mapping - they match a request <url-pattern> to an actual servlet class
* Key point: clients request servlets by <url-pattern>, NOT by <servlet-name> or <servlet-class>!
* The THREE types of <url-pattern> elements
    * EXACT match - MUST begin with a slash
    * DIRECTORY match - MUST begin with a slash
    * EXTENSION match - MUST begin with an asterisk (*)

## Key rules about servlet mappings
* The Container looks for matches in the order shown above. In other works, it looks first for an *exact* match. If it can't find an *exact* match, it looks for a directory match. If it can't find a *directory* match, it looks for an *extension* match
* If a request matches more than one directory <url-pattern>, the Container chooses the longest mapping. The most *specific* match always wins

## Configuring welcome files in the DD    
* Multiple welcome files go in a single DD element
    * No matter how many welcome files you might list, you put them ALL into a single entry in the DD: <welcome-file-list>. Each file has it own <welcome-file> element, but you put ALL of them within a single <welcome-file-list>
* The files in the <welcome-file> element do NOT start with a slash!
* The Container will pick the *first* match it finds, starting with the first welcome file listed in the <welcome-file-list>

## How the Container chooses a welcome file

## Configuring error pages in the DD
* Declare <error-page> in the DD
* You can't use <error-code> and <exception-type> together!
* You must use the fully-qualified class name in <exception-type>, and any Throwable is allowed
* You *can* generate error codes, that the method is *response.sendError()*. There's no difference between Container-generated and programmer-generated HTTP errors

## Configuring servlet initialization in the DD
* By default, servlets are initialized at first request
* If you want servlets to be loaded at deploy time rather than on first request, use the <load-on-startup> element in the DD
* Any non-negative value for <load-on-startup> tells the Container to initialize the servlet when the app is deployed
* If you have multiple servlets that you want preloaded, and you want to control the order in which they're initialized, the value of <load-on-startup> determines the order

## Making an XML-compliant JSP: a JSP Document
* A normal JSP is a *page*, unless it's written with the XML alternatives to normal JSP syntax, in which case it becomes a *document*
* Normal JSP *page* syntax - JSP *document* syntax
* Directives (except taglib)
    * <%@ page import="java.util.*" %>
    * <jsp:directive.page import="java.util.*" />
* Declaration
    * <%! int y = 3; %>
    * <jsp:declaration> int y = 3; </jsp:declaration>
* Scriptlet
    * <% list.add("ABC"): %>
    * <jsp:scriptlet> list.add("ABC"); </jsp:scriptlet>
* Text
    * ABC DEF
    * <jsp:text> ABC DEF </jsp:text>
* Scripting Expression
    * <%= it.next() %>
    * <jsp:expression> it.next() </jsp:expression>
    
## Memorizing the EJB-related DD tags
* If you're deploying an app in a full J2EE-compliant Container, you can define references to EJBs in the DD
* Reference to a *local* bean
* A LOCAL bean means the client and the bean must be running in the same JVM
    * <ejb-local-ref>
        * <ejb-ref-name>ejb/Customer</ejb-ref-name> - JNDI lookup name
        * <ejb-ref-type>Entity</ejb-ref-type>
        * <local-home>com.somallg.CustomerHome</local-home> - must be fully-qualified names of the bean's exposed interfaces
        * <local>com.somallg.Customer</local> - must be fully-qualified names
* Reference to a *remote* bean
* A REMOTE bean means the client and the bean can be running in different JVMs
    * <ejb-ref>
    * <ejb-ref-name>
    * <ejb-ref-type>
    * <home>
    * <remote>
* The LOCAL and REMOTE tags are inconsistent!
* Both the local and remote bean DD tags have two elements that are the same:
    * <ejb-ref-name> - lists the logical lookup name to perform JNDI lookup
    * <ejb-ref-type> describes whether this is an Entity or Session bean
* In other words, the local reference says it's local, but the remote reference does NOT include the word "remote" in its tag element name    

## Memorizing the JNDI <env-entry> DD tag
* Think of an environment entry as being something like a deploy-time constant that your app can use, much like servlet and context init parameters (i.e a way for developer to pass values into the servlet)
* Declaring an app's JNDI environment entry
    * *<env-entry>
        * <env-entry-name>rates/discountRate</env-entry-name>
        * <env-entry-type>java.lang.Integer</env-entry-type>
        * <env-entry-value>10</env-entry-value>
    * </env-entry>
* The <env-entry-type> must NOT be an primitive! You can use any type that types a single String in its constructor (or single Character for a Character type)

## Memorizing the <mime-mapping> DD tag
* You can configure a mapping between an extension and a mime type in the DD
* Declaring a <mime-mapping>
    * <mime-mapping>
        * <extension>mpg</extension>
        * <mime-type>video/mpeg</mime-type>
* Don't include the "." in the extension!        

## Mock exam
1 A
2 C E
3 B
4 C
5 B 
6 C
7 B D
8 A D
9 A C
10 A C 
11 C D 
12 A B
13 D
14 A