## 12. Keep it secret, keep it safe
* Objective - Web Application Security

## The Big 4 in servlet security
* Servlet security boils down to four main concepts: *authentication*, *authorization*, *confidentiality*, and *data integrity*

## How to Authenticate in HTTP World: the beginning of a secure transaction

## How did the Container do that?
* Things the Container did:
    * Performed a *lookup* on the resource being requested
    * Performed some *authentication*
    * Performed some *authorization*
    
## Keep security out of the code!
* For most web apps, most of the time, the web app's security constraints should be handled *declaratively*, in the DD
* Top Ten Reasons to do you security declaratively
    * Who doesn't need more XML practice?
    * Often maps naturally to the existing job roles in a company's IT department
    * Looks great on you resume
    * Allows you to use servlets you've already written in more flexible ways
    * It's on the exam
    * Allows application developers to reuse servlets without access to the source code
    * It's just cool
    * Reduces ongoing maintenance when your application grows
    * Finally, a way to justify the cost of that Container...
    * Supports the idea of component-based development
    
## Just enough Authentication to discuss Authorization
* The security "realm"
    * A *realm* is a place where *authentication* information is stored
* The tomcat-users.xml file
* Enabling authentication

## Authorization Step 1: defining roles
* Map the *roles* in the vendor-specific *users file* to *roles* established in the DD
* Vendor-specific
* Servlet-specification
* The deployer creates <role-name> elements in the DD< so that the Container can map roles to users

## Authorization Step 2: defining resource/method constraints
* Most of the security word you'll do is probably with <security-constraint> elements in your DD
* <auth-constraint> element list which roles CAN invoke the constrained HTTP Methods

## The <security-constraint> rules for <web-resource-collection> elements
* The purpose of <web-resource-collection> sub-element is to tell the container which resource and HTTP Method combinations should be *constrained* in such a way that they can be accessed only be the roles in corresponding <auth-constraint> tag
* Key points about <we-resource-collection>
    * The <web-resource-collection> element has two primary subâ€“elements:
        * <url-pattern> (one or more)
        * <http-method> (optional, zero or more)
    * The URL patterns and HTTP Methods together define resource requests that are *constrained* to be accessible by only those roles defined in <auth-constraint>
    * A <web-resource-name> element is MANDATORY (even though you probably won't use it for anything)
    * A <description> element is OPTIONAL
    * The <url-pattern> element uses servlet servlet standard naming and mapping rules
    * You *must specify at least one <url-pattern>, but you can have many
    * Valid Methods for the <http-method> element are: GET, POST, PUT, TRACE, DELETE, HEAD and OPTIONS
    * If *no* HTTP Methods are specified then *ALL* Methods will be constrained (which means they can be accessed only by the roles in <auth-constrain>)!!
    * If you DO specify an <http-method>, then only those methods specified wil be constrained. In other words, once you specify even a single <http-method> you automatically enable any HTTP Methods which you have *not* specified
    * You can have more than one <web-resource-collection> element in the same <security-constraint>
    * The <auth-constraint> element applies to ALL <web-resource-collection> elements in the <security-constraint>
* Constraints are not at the RESOURCE level. Constraints are at the HTTP REQUEST level
    * It's tempting to think that resources themselves are constrained. But it's really the combination of resource + HTTP Method
    * The <auth-constraint> element does NOT define which roles are allowed to access the resources from the <web-resource-collection>. Instead, it defines which roles are allowed to make the *constrained request*
    * If you specify an <http-method> element, all the HTTP methods you do NOT specify are UNconstrained
    * Any HTTP Methods supported by your Servlet will be allowed UNLESS you do one of two things:
        * Do not specify ANY <http-method> elements in the <security-constraint>, which means that ALL Methods are constrained to the roles in <auth-constraint>
        * Explicitly list the Method using <http-method> element. Once you have even a single <http-method> in the security constraint, then all other supported HTTP Methods will be UNconstrained
        
## Picky <security-constraint> rules for <auth-constraint> sub-elements
* Even though it's got *constraint* in its name, this is the sub-element that specifies which roles are ALLOWED to access the web resources specified by the *<web-resource-collection>* sub-element(s)
* The <auth-constraint> sub-element of <security-constraint>
    * <role-name> rules
        * Within an <auth-constraint> element, the <role-name> element is OPTIONAL
        * If <role-name> elements exist, they tell the Container which roles are ALLOWED
        * If an <auth-constraint> element exists with NO <role-name> element, then NO USERS ARE ALLOWED
        * If <role-name>*</role-name> then ALL users are ALLOWED
        * Role names are *case-sensitive*
    * <auth-constraint> rules
        * Within a <security-constraint> element, the <auth-constraint> element is OPTIONAL
        * If an <auth-constraint> exists, the Container MUST perform authentication for the associated URLs
        * If an <auth-constraint> does NOT exist, the Container MUST allow unauthenticated access for these URLs
        * For readability, you can add a <description> inside <auth-constraint>
        * NO <auth-constraint> is the opposite of an EMPTY <auth-constraint/>        
        
## How multiple <security-constraint> element interact
* Multiple <security-constraint> elements might conflict
* Multiple <security-constraint> elements with the same (or partly-matching) URL patterns and <http-method> elements
* When two different non-empty <auth-constraint> elements apply to the same constrained resource, access is granted to the union of all roles from both of the <auth-constraint> elements
* Rules for interpreting this table:
    * When combining individual role names, *all* of the role names listed will be allowed
    * A role name of "*" combines with anything else to allow access to *everybody*
    * An empty <auth-constraint> tag combines with *anything* else to allow access to nobody! In other words, an empty <auth-constraint> is always the final word!
    * If one of the <security-constraint> element has *no* <auth-constraint> element, it combines with anything else to allow access to *everybody*
    
## Customizing methods: isUserInRole()
* In *HttpServletRequest*, three methods are associated with programmatic security:
    * *getUserPrincipal()*
    * *getRemoteUser()*
    * *isUserInRole()*
* How it works:
    * Before isUserInRole() is called, the user needs to be *authenticated*. If the method is called on a user that has *not* been authenticated, the Container will always return false
    * The Containers takes the isUserInRole() argument, and compares it to the roles defined for the user in this request
    * If the user *is* mapped to this role, the Container returns true
* The <security-role-ref> element maps programmatic (hard-coded) role names to declarative <security-role> elements
* The Container will use a <security-role-ref> mapping even IF the programmatic name matches a "real" <security-role> name
    * When the Container hits an argument to "isUserInRole()", it looks FIRST for a matching <security-role-ref>. If it finds one, that's what it uses, even when the hard-code name really DOES match a <security-role> name
    
## Authentication revisited
* For a J2EE Container, authentication comes down to this: ask for a user *name* and *password*, then verify that they *match*
* The FOUR authentication types
    * BASIC authentication transmits the login information in an encoded (*not encrypted*) form - encoding scheme *base64* is really well known, BASIC provides very weak security
    * DIGEST authentication transmits the login information in a more secure way, but because the encryption mechanism isn't widely used, J2EE containers aren't required to support it
    * CLIENT-CERT authentication transmits the login information in an extremely secure form, using Public Key Certificates (PKC). The downside to this mechanism is that your client need to have a certificate before they can login to your system
    * FORM authentication lets you create your own custom login form out of anything that's legal HTML. The username and password are sent back in the HTTP request, with *no* encryption
    
## Implementing Authentication
* Simply declare the authentication scheme in the DD. The main DD element for authentication is <login-config>
* <login-config>
    * <auth-method>BASIC</auth-method>
* </login-config>
* Except for FORM, once you've declared the <login-config> element in the DD, implementing Authentication is done! (Assuming you've already configured username/password/role info into your server)

## Form-Based Authentication
* What YOU do:
    * Declare <login-config> in the DD
    * Create an HTML login form
    * Create an HTML error form
* Three entries in the HTML login form are the key to communicating with the container:
    * j_security_check - POST
    * j_username - input type text
    * j_password - input type password

## Summary of Authentication types
* Type - Spec - Data Integrity - Comments
* BASIC - HTTP - Base64 weak - HTTP standard, all browsers support it
* DIGEST - HTTP - Stronger but not SSL - Optional for HTTP and J3EE containers
* FORM - J2EE - very weak, no encryption - Allows a custom login screen
* CLIENT CERT - J2EE - Strong, public key - Strong, but users must have certificates
* Data *integrity* means that the data that arrives is the same as the data was sent (i.e nobody tampered with it along the way)
* Data *confidentiality* means that nobody else can see the data along the way
* Most of the time, we treat data integrity *and* confidentiality as a single goal - things you do to *protect data during transmission*

## Securing data in transmit: HTTPS to the rescue
* Wen you tell a J2EE Container that you want to implement data confidentiality and or integrity, the J2EE spec guarantees that the data to be transmitted will travel over a "protected transport layer connection"
* Containers are not *required* to use any specific protocol to handle secure transmission, but in practice they nearly all use HTTPS over SSL

## How to implement data confidentiality and integrity sparingly and declaratively
* We use <security-constraint> for both confidentiality and integrity by adding an element called *<user-data-constraint>*
* Legal values for <transport-guarantee>
    * NONE - this is the default, and it means there's no data protection
    * INTEGRAL - the data must not changed along the way
    * CONFIDENTIAL - the data must not be seen by anybody along the way
    * NOTE: although not guaranteed by the spec, in practice virtually every Container uses SSL for guaranteed transport, which means that both INTEGRAL and CONFIDENTIAL do the same thing - either one gives you both confidentiality and integrity
   
## Protecting the request data
* <security-constraint> is about what happens *after* the request. In other words, the client has already made the request when the Container starts looking at the <security-constraint> elements to decide how to respond
* The request data has already been sent over thew wire

## Unauthorized client requests a constrained resource that has NO transport guarantee
* When a request comes in, the Container looks FIRST at the <transport-guarantee>, and if there IS one, the Container tries to deal with that issue first by asking, "is this request over a secure connection?" If not, the Container doesn't even bother to look at authentication/authorization info
* To make sure the user's login info is submitted to the server securely, put a transport guarantee on EVERY constrained resource that could trigger the login process!

## Mock exam
1 A
2 A
3 D
4 F
5 B
6 A C
7 C
8 D
9 B
