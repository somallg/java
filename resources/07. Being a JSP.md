## Being a JSP
* Objectives - The JSP Technology Model
    * 6.1 Identify, describe, or write JSP code for the following elements: (a) template text, (b) scripting elements (comments, directives, declarations, scriptlets, and expressions), (c) standard and custom actions, and (d) expression language elements
    * 6.2 Write JSP code that uses the directives: (a) *page* (with attributes *import*, *session*, *contentType*, and *isELIgnored*), (b) *include*, and (c) *taglib*
    * 6.3 *Write a JSP Document (XML-based document) that uses the correct syntax
    * 6.4 Describe the purpose and event sequence of the JSP page lifecycle: (1) JSP page translation, (2) JSP page compilation, (3) load class, (4) create instance, (5) call the jspInit method, (6) call the _jspService method, and (7) call the jspDestroy method
    * 6.5 Given a design goal, write JSP code using the appropriate implicit objects: (a) request, (b) response, (c) out, (d) session, (e) config, (f) application, (g) page, (h) pageContext, and (i) exception
    * 6.6 Configure the deployment descriptor to declare one or more tag libraries, deactivate the evaluation language, and deactivate the scripting language
    * 6.7 Given a specific design goal for including a JSP segment in another page, write the JSP code that uses the most appropriate inclusion mechanism (the include directive or the jsp:include standard action)
    
## In the end, the JSP is just a servlet
* The Container takes what you've written in your JSP, *translates* it into a servlet class source (.java) file, the *compiles* that into a Java servlet class

## Making a JSP that displays how many times it's been accessed

## Use the page directive to import packages
* A *directive* is a way for you to give special instructions to the Container at page translation time
* Directives come in three flavors: *page*, *include*, and *taglib*
* *page* directive lets you *import*
* Use a comma to separate the packages. The quotes go around the entire list of packages! 
* If you see JSP code that starts with %@, you know it's a directive
* Three different JSP element types:
    * Scriptlet: <% %>
    * Directive: <%@ %>
    * Expression: <%= %>
* Expressions become the argument to an out.print()
* NEVER end an *expression with a semicolon!

## What REALLY happens to your JSP code?
* You *write* a JSP, but it *becomes* a servlet
* ALL scriptlet ans expression code lands in a service method
* That means variables declared in a scriptlet are always LOCAL variables!

## We need another JSP element...
* *Directives* are for special instructions to the Container
* *Scriptlets* are just plain old Java that lands as-is within the generated servlet's service method
* The result of an *expression* always becomes the argument to a print() method
* Anything between the <%! and %> tag is added to the class *outside* of the service method

## JSP Declarations
* A JSP declaration is always defined *inside* the class but *outside* the service method
* Declarations are for static and instance variables and methods

## Time to see the REAL generated servlet
* What the Container does with your JSP
    * Looks at the *directives*, for information it might need during translation
    * Create an HttpServlet subclass
    * If there's a *page directive* with an *import* attribute, it writes the import statements at the top of the class file, just below the package statement
    * If there are *declarations*, it writes them into the class file, usually just below the class declaration and before the service method
    * Build the *service* method. The service() method's actual name is *_jspService()*. It's called by the servlet superclass overridden service() method, and receives the HttpServletRequest and HttpServletResponse. As part of building this method, the Container declares and initializes all the *implicit objects
    * Combines the plain old HTML (called template text), *scriptlets*, and *expressions* into the service method, formatting everything and writing in to the PrintWriter response output
    
## The out variable isn't the only implicit object...
* When a Container translates the JSP into a Servlet, the beginning of the service method is a pile of *implicit object* declarations and assignments
* With implicit objects, you can write a JSP knowing that your code is going to be part of a servlet
* API - Implicit Object
* JSPWriter - out
* HttpServletRequest - request
* HttpServletResponse - response
* HttpSession - session
* ServletContext - application
* ServletConfig - config
* Throwable - exception
* PageContext - pageContext
* Object - page

## A comment...
* You can put two different types of comments in a JSP:
    * <!-- HTML comment -->
    * <%-- JSP comment -->
    
## API for the generated servlet
* The Container generates a class from your JSP that implements the HttpJspPage interface
* Three key methods:
    * jspInit()
    * jspDestroy()
    * _jspService()
    
## Lifecycle of a JSP

## Translation and compilation happens only ONCE

## Initializing your JSP
* Configuring servlet init parameters
    * You have to add *jsp-file* element within the *servlet* tag
* Overriding jspInit()

## Attributes in a JSP
* Four attribute scopes in a JSP: servlet request, session, application, page
* There's no such thing as *context* scope... even though attributes in *application* scope are bound to the ServletContext object

## Using PageContext for attributes
* You can use a PageContext reference to get attributes from any scope
* JspContext
    * getAttribute(String)
    * getAttribute(String, int scope)
    * getAttributeNamesInScope(int scope)
    * findAttribute(String)
* PageContext
    * APPLICATION_SCOPE
    * PAGE_SCOPE
    * REQUEST_SCOPE
    * SESSION_SCOPE
    * getRequest()
    * getServletConfig()
    * getServletContext()
    * getSession()
* Using the *pageContext* to find an attribute when you don't know the scope
    * pageContext.findAttribute("foo")
    * Find from most restricted to least restricted scope - page, request, session, application scope
    * The first one it finds with that name wins

## While we're on the subject... let's talk more about the three directives
* The *page* directive
    * Defines page-specific properties such as character encoding, the content type for this page's response, and whether this page should have implicit session object
* The *taglib* directive
    * Defines tag libraries available to the JSP
* The *include* directive
    * Defines text and code that gets added into the current page at translation time
    
## Attributes to the page directive
* *POSSIBLY* on the exam
    * import - defines the Java import statement that will be added to the generated servlet class. Some import for free (by default): *java.lang*, *javax.servlet*, *javax.servlet.http*, and *javax.servlet.jsp*
    * isThreadSafe - defines whether the generated servlet needs to implement the SingleThreadModel
    * contentType - defines the MIME type (and the optional character encoding) for the JSP response
    * isELIgnored - defines whether EL expressions are ignored when this page is translated
    * isErrorPage - defines whether the current page represents *another* JSP's error page. The default value is "false", but if it's true, the page has access to the implicit *exception* object
    * errorPage - defines a URL to the resource to which uncaught Throwable should be sent. If you define a JSP here, then *that* JSP will have an *isErrorPage="true"* attribute in *its* page directive
* NOT on the exam
    * language - defines the scripting language used in scriptlets, expressions, and declarations. Right now, the only possible value is "java"
    * extend - defines the superclass of the class this JSP will become
    * session - defines whether the page will have an implicit *session* object (default = true)
    * buffer - defines how buffering is handled by the implicit *out* object (reference to the JspWriter)
    * autoFlush - defines whether the buffered output is flushed automatically (default = true)
    * info - defines a String that gets put into the translated page, just so that you can *get* in using the generated servlet's inherited *getServletInfo()* method
    * pageEncoding - defines the character encoding for the JSP (default = ISO-8859-1)
    
## Scriptlets considered harmful?
* Some people believe (*lot* of people including the JSP and Servlet spec teams) that it's *bad practice* to put all this Java into your JSP

## There didn't used to BE an alternative
* You've got to know how to *read* and *understand* these elements, and how to *maintain* pages written with them
* For the time being, you still have to be able to work it it!

## EL: the answer to, well, everything
* Certainly an answer to two big complaints about putting actual Java into a JSP:
    * Web page designers shouldn't have to know Java
    * Java code in a JSP is hard to change and maintain
* The purpose of EL (Expression Language) is to offer a simpler way to *invoke* Java code - but the code itself belongs *somewhere else*
* In other words, you don't write method code into your JSP when you're following today's Best Practices. You write Java method *somewhere else*, and *call* it using EL

## Sneak peek at EL
* An EL expression ALWAYS looks like this: ${something}
* In other words, the expression is ALWAYS enclosed in curly braces, and prefixed with a dollar $ sign
* This EL expression:
    * ${application.mal}
* Is the same as this Java expression:
    * <%= application.getAttribute("mail") %>

## Using <scripting-invalid>
* You can make it invalid for a JSP to have scripting elements (scriptlets, Java expressions, or declarations) by putting a <scripting-invalid> tag in the DD
* Watch out - isScriptingEnabled attribute is no longer in the JSP spec
* The *only* way to invalidate scripting now is through the <scripting-invalid> DD tag

## You can choose to ignore EL
* EL is enabled by default!
* If you want EL-looking things in your JSP to be ignored, you have to say so explicitly, either though a page directive or a DD element
    * Putting <el-ignored> in the DD
    * Using the isELIgnored page directive attribute
* the page directive takes priority over the DD setting!
* Watch out for the naming inconsistency

## But wai... there's still another JSP element we haven't see: action

1 C
2 D
3 B C D E
4 A B C D
5 A B
6 D
7 D
8 C
9 C E
10 A 
11 A B F
12 B 
13 D
14 C
15 C
16 A
