## When even JSTL is not enough...
* Objectives - Building a Custom Tag Library

## Includes and imports can be messy

## Tag Files: like include, only better
* With Tag Files, you can invoke reusable content using a custom tag instead of the generic <jsp:include> or <c:import>
* Think od Tag Files as a kind of "tag handler lite", because they let page developers create custom tags, without having to write a complicated Java tag handler class, but Tag Files are really just glorified *includes*
* Simplest way to make and use a Tag File
    * Take an included file and rename it with a .tag extension
    * Put the tag file in a directory named "tags" inside the "WEB-INF" directory
    * Put a taglib directive (with a *tagdir* attribute) in the JSP, and invoke the tag
    * Use the "tagdir" attribute in the taglib directive, instead of the "uri" we use with TLDs for tag libraries
    * The name of the tag is simply the name of the tag file! (minus the .tag extension)
    
## But how do you sent it parameters?
* When we included a file using <jsp:include>, we used the <jsp:param> tag inside the <jsp:include> to pass information to the included file

## To a Tag File, you don't send request parameters, you send tag attribute!
* You invoke a Tag File with a tag, and tags can have attributes
* Invoking the tag from the JSP
    * <mytags:header subTitle="ABC" />
* Using the attribute in the Tag File
    * ${subTitle}
* All tag attributes have TAG scope. That's right, just the tag. Once the tag is closed, the tag attributes go out of scope!

## Aren't tag attributes declared in the TLD ?

## Tag Files use the attribute directive
* It's just like the <attribute> sub-element in the <tag> section of the TLD for a custom tag
    * <%@ attribute name="subTitle" required="true" rtexprvalue="true %>
    
## When an attribute value is really big
* You can choose to put content in the body of the tag, and then use that as a kind of attribute
* We take out the subTitle attribute *out* of the tag, and instead make it the *body* of the tag
* <jsp:doBody> - this say,"take whatever is in the body of the tag used to invoke this tag file, and stick it here"
* Now you just give the tag a body, instead of putting all this as the value of an attribute in the opening tag

## Declaring body-content for a Tag File
* The only way to declare body-content type for a Tag File is with another new Tag File directive, the *tag directive*
* *Tag File bodies are never allowed to have scripting*
* You CANNOT use scripting code in the body of a Tag File tag!
* The body-content of a Tag File defaults to "scriptless", so you don't have to declare body-content unless you want on of the OTHER two options: "empty" (nothing in the tag body) or "tagdependent" (treats the body as plain text)
* <%@ tag body-content="tagdependent" %>

## Where the Container looks for Tag Files
* Directly inside WEB-INF/tags
* Inside a sub-directory of WEB-INF/tags
* Inside the META-INF/tags directory inside a JAR file that's inside WEB-INF/lib
* Inside a sub-directory of META-INF/tags inside a JAR file that's inside WEB-INF/lib
* IF the tag file is deployed in a JAR, there MUST be a TLD for the tag file
* Tag Files give non-Java developers a way to build custom tags *without* writing a Java class to handle the tags' functionality
* Custom tags *must* have a TLD, but Tag Files can declare attributes and body-content directly inside the Tag File, and need TLDs *only* if the Tag File is in a JAR

## Memorizing Tag Files

## When you need more than Tag Files... Sometimes you need Java
* Tag files implement the tag functionality with another pages (using JSP)
* Tag handlers implement the tag functionality with a special Java class
* Tag handlers come in two flavors: Simple and Classic
* Like scripting, Classic tag handler are out there, and you might need to read and support them, even if you never *create* one yourself
* There are those rare scenarios for which a classic tag handler is the best choice

## Making a Simple tag handler
* Write a class that extends *SimpleTagSupport*
* Override the *doTag() method
* Create a TLD for the tag
* Deploy the tag handler and TLD
* Write a JSP that *uses* the tag

## The Simple tag API
* A Simple tag handler must implement the SimpleTag interface
* JspTag interface
* SimpleTag interface
    * void doTag()
    * JspTag getParent()
    * void setJspBody(JspFragment)
    * void setJspContext(JspContext)
    * void setParent(JspTag parent)
* SimpleTagSupport
    * JspTag findAncestorWithClass(JspTag, Class)
    * JspFragment getJspBody()
    * JspContext getJspContext()
    
## The life of a Simple tag handler
* When a JSP invokes a tag, a new instance of the tag handler class is instantiated, two or more methods are called on the handler, and when the doTag() method completes, the handler object goes away (i.e, these handler objects are *not* reused)
    * Load class
    * Instantiate class (no-arg *constructor* runs)
    * Call the *setJspContext(JspContext) method
    * If the tag is nested, call the *setParent(JspTag) method
    * If the tag has attributes, call *attribute setters*
    * If the tag is NOT declared to have a <body-content> of empty, AND the tag has a body, call the *setJspBody(JspFragment) method
    * Call the *doTag()* method

## What if the tag body uses an expression?
* The tag handler sets an attribute and THEN invokes the body

## A tag with dynamic row data: iterating the body
* doTag() method simply does the work in a loop, invoking the body on each iteration of the loop
* Each loop of the Tag handler resets the attribute value and calls getJspBody().invoke() again

## A Simple tag with an attribute
* If the tag needs an attribute, you declare it in the TLD, and provide a bean-style setter method in the tag handler class for each attribute
* If the tag invocation includes attributes, the Container invokes a setter method for each attribute
* The method name MUST match the attribute name in the TLD (minis the "set" prefix and changing the case of the first letter)

## What exactly IS a JspFragment?
* JspFragment is an object that represents JSP code
* Its sole purpose in life is to be invoked
* In other words, it's something that's mean to *run* and generate *output*
* The body of a tag that invokes a simple tag handler is encapsulated in the JspFragment object, then sent to the tag handler in the *setJspBody()* method
* JspFragment must NOT contain any scripting elements
* It can contain template text, standard and custom actions, and EL expression, but NO scriptlets, declaration, or scripting expressions
* The invoke() method takes a Writer... pass null to send the body to the response output, or a Writer if you want direct access to the actual body contents

## SkipPageException: stops processing the page...
* The rest of the tag AND the rest of the page should stop. Only the part of the page and the tag BEFORE the exception will appear in the response

## SkipPageException shows everything up to the point of the exception
* Everything in the *doTag()* method up to the point of the SkipPageException still shows up in the response
* But after the exception, anything still left in either the tag or the page won't be evaluated

## But what happens when the tag is invoked from an included page?

## SkipPageException stops only the page that directly invoked the tag
* The original page that did the includes keeps going after the SkipPageException

## Simple Tag bullet points
* Tag Files implement tag functionality using a *page*, while tag handlers implement tag functionality using a Java tag handler *class*
* Tag handlers come in two types: *Classic* and *Simple* (Simple tags and Tag Files were added in JSP 2.0)
* To make a Simple tag handler, extend *SimpleTagSupport* (which implements the *SimpleTag* interface)
* To deploy a Simple tag handler, you must create a TLD that describes the tag using the same <tag> element used by JSTL and other custom tag libraries
* To use a Simple tag with a body, make sure the TLD <tag> for this tag does not declare <body-content> empty. Then call *getJspBody().invoke()* to cause the body to be processed
* The *SimpleTagSupport* class includes implementation methods for everything in the *SimpleTag* interface, plus three convenience methods including *getJspBody()*, which you can use to get access to the contents of the body of the tag
* The Simple tag lifecycle: *Simple tags are never reused by the Container*, so each time a tag is invoked, the tag handler is instantiated, and its *setJspContext()* method is invoked. If the tag is called from within another tag, the *setParent()* method is called. If the tag is invoked with attributes, a bean-style setter method is invoked for each attribute. If the tag is invoked with a body (assuming its TLD does NOT declare it to have an empty body), the *setJspBody()* method is invoked. Finally, the *doTag()* method is invoked, and when its completes, the tag handler instance is destroyed
* The *setJspBody() will be invoked ONLY if the tag is actually called with a body*. If the tag is invoked without a body, either with an empty tag <my:tag/> or with nothing between the opening and closing tags <my:tags></my:tags>, the *setJspBody()* method will NOT be called. Remember, if the tag has a body, the TLD must reflect that, and the <body-content> must not have a value of "empty"
* The Simple tag's doTag() method can set an attribute used by the body of the tag, by calling getJspContext().setAttribute() followed by getJspBody().invoke()
* the *doTag() method declares a JspException and an IOException*, so you can write to the JspWriter without wrapping it in a try/catch
* You can iterate over the body of a Simple tag by invoking the body (getJspBody().invoke()) in a loop
* If the tag has an attribute, declare the attribute in the TLD using an <attribute> element, and *provide a bean-style setter method in the tag handler class*. WHen the tag is invoked, the setter method will be called *before* doTag()
* The getJspBody() method returns a JspFragment, which has two methods: *invoke(java.io.Writer)*, and *getJspContext()* that returns a JspContext, the tag handler can use to get access to the PageContext API (to get access to implicit variables and scoped attributes)
* Passing *null* to invoke() writes the evaluated body to the response output, but you can pass another Writer in if you want direct access to the body contents
* Throws a *SkipPageException* if you want the current page to stop processing. If the page that invoked the tag was included from another page, the including page keeps going even though the included page stops processing from the moment the exception is thrown

## You still have to know about Classic tag handlers

## Tag handler API
* The tag handler API has *five* interfaces and *three* support classes
* There's virtually NO reason to implement the interfaces directly, so you'll probably always extends a support class

## A very small Classic tag handler
* A JSP that invokes a Classic tag
* The TLD <tag> element for the Classic tag
* The Classic tag handler
    * extends *TagSupport*
    * implement *doStartTag()* throws JspException
    * Classic tags inherit a *pageContext* member variable from TagSupport
    * return an int to tell the Container what to do next
    
## When a tag has a body: comparing Simple vs Classic
* SimpleTag bodies are evaluated when you want by calling invoke() on the JspFragment that encapsulates the body
* But in Classic tags, *the body is evaluated in between the doStartTag() and doEndTag() methods!*
* It's easy to loop the body of a Simple tag; you just keep calling invoke() on the bod, from within doTag(0)

## Classic tags have a different lifecycle
* Load class
* Instantiate class (no-arg constructor runs)
* Call the *setPageContext(PageContext)* method
* If the tag is nested, call the *setParent(Tag)* method
* If the tag has attributes, call *attribute setters*
* Call the *doStartTag()* method
* If the tag is NOT declared to have an empty body, AND the tag is NOT invoked with an empty body, ADN the doStartTag() method returns EVAL_BODY_INCLUDE, the body is evaluated
* If the body content was evaluated, call the *doAfterBody()* method
* Call the *doEndTag()* method

## The Classic lifecycle depends on return values
* The constants used as return values for doStartTag() and doEndTag() return value constants are inconsistently named!
* EVAL_BODY_AGAIN is the only return value constant declared in IterationTag (the others are all from Tag)
* Returning SKIP_PAGE from doEndTag() is exactly like throwing a SkipPageException from a Simple tag! If a page included the page that invoked the tag, the current (included) page stops processing, but the including page continues...

## IterationTag lets you repeat the body
* Without doAfterBody(), you can't iterate over the body because doStartTag() is too early, and doEndTag() is too late

## Default return values from TagSupport
* If you don't override the TagSupport lifecycle methods that return an integer, be aware of the default values the TagSupport method implementations return
* Default return values when you don't override the TagSupport method implementation
    * doStartTag() - SKIP_BODY
    * doAfterBody() - SKIP_BODY
    * doEndTag() - SKIP_PAGE
* The TagSupport class assumes your tag doesn't have a body, or that if the body IS evaluated, that the body should be evaluated only ONCE
* It also assumes that you always want the rest of the page to be evaluated
* doStartTag() and doEndTag() run exactly once
* You MUST override doStartTag() if you want the tag body to be evaluated
* The Container can reuse Classic tag handler!

## Our tag handler code using the DynamicAttributes interface
* Implement the *DynamicAttributes* interface from the JSP API
* Implement the *setDynamicAttribute()* method - this method needs to store the attribute name/value pairs; a hash-map is the perfect data structure to hold this information
* Add <dynamic-attributes> = true - this element is all you need to declare that this tag may accept any number of dynamic attributes

## What about Tag Files?
* Tag Files can also include dynamic attributes
* The mechanism is basically the same, but with Tag Files the JSP engine provides the *Map* object for you
* You can then inspect or iterate over that Map of attribute/value pairs using the *forEach* JSTL tag

## Bullet Points
* The *DynamicAttributes* interface allows the tag handler class to accept any number of tag attributes
* The tag declaration in the TLD must include the *<dynamic-attributes>* element
* Explicit tag attributes must have a setter method
* Typically, you will use a hashMap to store the dynamic attribute name/value pairs using the *setDynamicAttribute()* method
* Tag Files may also use dynamic attributes
* Use the *dynamic-attributes* attribute of the tag directive
* The value of *dynamic-attributes* holds a hashMap of the dynamic attributes
* Typically, you will use the JSTL *foreach* custom action to iterate over this map

## But what if you DO need access to the body content?
* Extending BodyTagSupport gives you two more lifecycle methods from the BodyTag interface - setBodyContent() and doInitBody(). You can use these to do something with the actual CONTENTS of the body of the tag used to invoke the handler

## With BodyTag, you get two new methods
* When you implement BodyTag (by extends BodyTagSupport), you get two more lifecycle methods - setBodyContent() and doInitBody()
* You also get one new return value for *doStartTag()*, EVAL_BODY_BUFFERED

## With BodyTag, you can buffer the body
* the BodyContent argument to *setBodyContent()* is actually a type of java.io.Writer
* If the TLD for a tag declares an empty body, doStartTag() must return SKIP_BODY!

## A Tag can call its Parent Tag
* Getting the parent tag
    * OuterTag parent = (OuterTag) getParent();

## Simple tags can have Classic parents
* SimpleTag's getParent() returns type JspTag, and Classic tags and Simple tags now share the JspTag super interface
* *Classic* tags can have *Simple* parents
* Using getParent(), a Classic tag can access Classic tag parents, and a Simple tag can access *either* a Classic or Simple parent
* Once you have a parent, you cal call method on it like any other Java object, so you can get attributes of the parent tag!
* If you return SKIP_BODY, the inner tag will never be processed!

## You can walk up, but you can't walk down...
* There's a getParent() method, but there's no getChild()

## Getting info from child to parent
* Simple-get a reference to the parent tag and call its addMenuItem() method

## Getting an arbitrary ancestor
* Getting an immediate parent using getParent()
    * OuterTag parent = (OuterTag) getParent()
* Getting an arbitrary ancestor using findAncestorWithClass()
    * WayOuterTag ancestor = (WayOuterTag) findAncestorWithClass(this, WayOuterTag.class);
    
## Using the PageContext API for tag handlers
* The one-arg getAttribute(String) is for page scope ONLY!
* findAttribute() looks in EACH scope starting with PAGE_SCOPE

1 B
2 A D E # tag files 
3 B 
4 C
5 B E
6 B D E
7 B C 
8 B 
9 B
10 E
11 B
12 C 
13 E
14 B E C G
15 D 
16 B
17 A C
18 D E F # tag files
19 A B D # tag files
20 A
21 A B
22 C
