# 6. Conversational state

## Objectives - Session Management
* 4.1 Write servlet code to store objects into a session object and retrieve objects from a session object
* 4.2 Given a scenario describe the APIs used to access the session object, explain when the session object was created, and describe the mechanisms used to destroy the session object, and when it was destroyed
* 4.3 Using session listeners, write code to response to an event when an object is added to a session, and write code to response to an event when a session object migrates from one VM to another
* 4.4 Given a scenario, describe which session management mechanism the Web container could employ, how cookies might be used to managed sessions, how URL rewriting might be used to manage sessions, and write servlet code to perform URL rewriting

## Kim wants to keep client-specific state across multiple requests

## How can he track the client's answers?
* An HttpSession object can hold conversational state across *multiple* requests from the same client
* In other words, it persists for an entire *session* with a specific client
* We can use it to store everything we get back from the client in all the requests the client makes during a session

## One problem... how does the Container know who the client is?
* HTTP protocol uses *stateless* connections
* The connection exists for only a *single* request/response
* *Because* the connections don't persist, the Container doesn't recognize that the client making a second request is the same client from the previous request
* As far as the Container's concerned, *each request is from a new client*

## The client needs a unique session ID
* The idea is simple: on the client's first request, the Container generates a unique session ID and gives it to the client with the response
* *The client sends back the session ID with each subsequent request*
* The Container sees the ID, find the matching session, and associates the session with the request

## How do the Client and Container exchange Session ID info?
* The simplest and most common way to exchange the info is through *cookies*

## The best part: the Container does virtually all the cookie work!
* You *do* have to tell the Container that you want to create or use a session, but the Container takes care of generating the session ID, creating a new Cookie object, stuffing the session ID into the cookie, and setting the cookie as part of the response
 * Sending a session cookie in the RESPONSE
    * HttpSession session = request.getSession();
    * This method does more than just create a session, but the FIRST time you invoke it on the request, it will cause a cookie to be sent with the response. There's still no guarantee the client will ACCEPT the cookie
* All the cookie work happens behind the scenes
* Getting the session ID from the request:
    * HttpSession session = request.getSession();

## What if I want to know whether the session already existed or was just created?
* getSession, returns a session *regardless of whether there's a pre-existing session*
* session.isNew() return *true* if the client has not yet responded with this session ID
* You can get a session... from a session *event* object

## What if I want ONLY a pre-existing session?
* If you don't want to create a new session, call getSession(false), and you'll get either null, or a pre-existing HttpSession

## You can do sessions even if the client doesn't accept cookies, but you have to do a little more work...
* Most browsers *do* have cookies enabled. *But there's no guarantee*    
* If cookies aren't enabled, it means the client will never join the session. In other words, *the sessions's isNew() method will always return true*
* A client with cookies disabled will ignore *Set-Cookie* response headers
* The client simply never sends back a request that has session ID cookie header

## URL rewriting: something to fall back on
* URL rewriting takes the session ID that's in the cookie and sticks it right onto the end of every URL that comes in to this app
    * URL + ;jsessionid=1234567

## URL rewriting kicks in ONLY if cookies fail, and ONLY if you tell the response to encode the URL
* If cookies don't work, the Container falls back to URL rewriting, but *only* if you've done the extra work of encoding all the URLs you send in the response
* If you don't *explicitly encode your URLs*,and the client won't accept cookies, *you don't get to use sessions*
* If you *do* encode URLs, the Container will first attempt to use cookies for session management, and fall back to URL rewriting only if cookie approach fail
* response.encodeURL("/BeerTest.do") - Add the extra session ID info to this URL

## URL rewriting works with sendRedirect()
* URL rewriting is automatic.. but only if you encode your URLs. YOU have to rull all your URLS through a method of the response object *encodeURL()* or *encodeRedirectURL()* and the Container does everything else
* Redirect the request to a different URL, but still want to use session:
    * response.encodeRedirectURL("/BeerTest.do")
* If you need URL rewriting, you have to dynamically generate the URLs in the response HTML, that means you have to process the HTML at runtime
* You can do URL rewriting in a JSP, with *c:URL* tag
* URL rewriting is handled in a vendor-specific way
* URL encoding is handled by the Response!
* Don't be fooled by a *request* parameter *jsessionid* or a *JSESSIONID* header

## Bullet Points
* URL rewriting adds the session ID to the end of all URLs in the HTML that you write to the response
* The session ID then comes back with the next request as *extra* info at the end of the request URL
* URL rewriting will happen automatically if cookies don't work with the client, but you have to *explicitly* encode all the URLs you write
* To encode a URL, call *response.encodeURL(String)*
* There's no way to get automatic URL rewriting with your static pages, so if you depend on sessions, you must use dynamically-generated pages

## Getting rid of sessions
* The point is, session objects take resources. You don't way session to stick around longer than necessary 
* HTTP protocol doesn't have any mechanism for the server to know that the client is one (there's no *leasing*)

## The HttpSession interface
* javax.servlet.http.HttpSession
    * Object getAttribute(String)
    * long getCreationTime()
    * String getId()
    * long getLastAccessedTime()
    * int getMaxInactiveInterval()
    * ServletContext getServletContext()
    * void invalidate()
    * boolean isNew()
    * void removeAttribute(String)
    * void setAttribute(String, Object)
    * void setMaxInactiveInterval(int)
* Most of the time, you'll use sessions to get and set session-scoped attributes

## Key HttpSession methods
* getCreationTime() - return the time the session is first created - to find out how old the session is
* getLastAccessedTime() - returns the last time the Container got a request with this session ID - to find out when a client last accessed this session
* setMaxInactiveInterval() - specifies the maximum time, in seconds, that you want to allow between client requests for this session - to cause a session to be destroyed after a certain amount of time has passed
* getMaxInactiveInterval() - return the maximum time, in seconds, that you want to allow between client requests for this session - to find out how long this session can be inactive and still be alive
* invalidate() - ends the session, includes *unbinding* all session attributes currently stored in this session - to kill a session if the client has been inactive or if you KNOW the session is over

## Setting session timeout
* Three ways a session can die:
    * It times out
    * You call invalidate() on the session object
    * The application goes down
* Configuring session timeout in the DD
    * Has virtually the same effect as calling *setMaxInactiveInterval()* on every session that's created
    * Setting the maximum inactive interval to 0 means the session times out and is invalidated immediately
    * *session-timeout* tag in minutes
* Setting session timeout for a *specific* session
    * session.setMaxInactiveInterval(20 * 60);
    * Only the session on which you call the method is affected
    
## BE the Container

## Can I use cookies for other things, or are they only for session?
* Although cookies *were* originally designed to help support session state, you *can* use custom cookies for other things
* You can use cookies to exchange name/value String pairs between the server and the client
* The server *sends* the cookie to the client, and the client *sends* it back with each subsequent request
* Session cookies vanish when the client's browser quits, bu you CAN tell a cookie to persist on the client event *after* the browser shuts down

## Using Cookies with the Servlet API
* You *can* get cookie-related headers out of the HTTP request and response, but *don't*
* Everything you need to do with cookies has been encapsulated in the Servlet API in three classes: HttpServletRequest, HttpServletResponse, Cookie
* javax.servlet.http.HttpServletRequest
    * getCookies()
* javax.servlet.http.HttpServletResponse
    * addCookie()
* javax.servlet.http.Cookie
    * new Cookie(String, String)
    * String getDomain()
    * int getMaxAge()
    * String getName()
    * String getPath()
    * boolean getSecure()
    * String getValue()
    * void setDomain(String)
    * void setMaxAge(int)
    * void setPath(String)
    * void setValue(String)
* Creating a new Cookie
    * Cookie cookie = new Cookie("userName", name)
* Setting how long a cookie will live on the client
    * cookie.setMaxAge(30 * 60)
* Sending the cookie to the client
    * response.addCookie(cookie);
* Getting the cookie(s) from the client request

## Simple custom cookie example

## Don't confuse Cookies with headers!
* When you add a *header* to a response, you pass the name and value String as arguments
* But when you add a *Cookie* to the response, you pass a Cookie object
* You must now the request and response methods to get and add Cookies. You should also know the Cookie constructor and the getMaxAge() and setMaxAge() methods

## Key milestones for an HttpSession

## Session lifecycle Events
* Lifecycle
    * The session was *created*
    * The session was *destroyed* - invalidate()
    * HttpSessionEvent
    * HttpSessionListener
* Attributes
    * An attribute was *added* - setAttribute()
    * An attribute was *removed* - removeAttribute()
    * An attribute was *replaced* - setAttribute()
    * HttpSessionBindingEvent
    * HttpSessionAttributeListener
* Migration
    * The session is *about* to be *passivated*
    * The session *has* been *activated*
    * HttpSessionEvent
    * HttpSessionActivationListener

## Don't forget about HttpSessionBindingListener
* Do NOT configure session binding listeners in the DD!
* HttpSessionListener and HttpSessionActivationListener must be registered in the DD, since they're related to the session itself, rather than an individual attribute placed in the session

## Session migration
* Only HttpSession objects (and their attributes) move from one VM to another
* There is one ServletContext *per* VM. There is one ServletConfig *per servlet, per VM*
* But there is only one HTTPSession object for a given session ID per web app, regardless of how many VM's the app is distributed across

## Session migration in action
* The key point is that while other parts of the apps are *replicated* on each node/VM, the session objects are *moved*

## HttpSessionActivationListener lets attributes prepare for the big move...
* Use this listener to give attributes a chance to make their instance variables ready for Serialization
* Session migration and Serialization
    * A Container is required to migrate Serializable attributes
    * But a Container is not required to use Serialization as the means for migrating the HttpSession object

1 E
2 B
3 A C
4 D
5 A B D
6 A B
7 A C E
8 C
9 F
10 A B
11 B
12 C D
13 B C
14 C
15 A C
16 C
17 A