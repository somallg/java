# SCJP 5 - Chapter 9 Threads## Defining, Instantiating, and Starting Threads* When it comes to threads, very little is guaranteed## Making a Thread* Thread methods:    * start()    * yield()    * sleep()    * run()## Defining a Thread* Extending java.lang.Thread. Override the run() method()* Implementing java.lang.Runnable. Override the run() method()## Instantiating a Thread* Every thread of execution begins as an instance of class Thread* Thread constructors:    * Thread()    * Thread(Runnable target)    * Thread(Runnable target, String name)    * Thread(String name)## Starting a Thread* Use start() method* A new thread of execution starts* The thread moves from the new state to the runnable state* When the thread gets a chance to execute, its target run() method with run* Thread.currentThread(): return the current running thread## Starting and Running Multiple Threads* Each thread will start, and each thread will run to completion* A thread is done being a thread when its target run() method completes* Once a thread has been started, it can never be started again## The Thread Scheduler* The thread scheduler decides which thread – of all that are eligible – will actually run* The order in which runnable threads are chosen to run is not guaranteed## Methods form the java.lang.Thread Class* public static void sleep(long millis) throws InterruptedException* public static void yield()* public final void join() throws InterruptedException## Methods from the java.lang.Object Class* public final void wait() throws InterruptedException* public final void notify()* public final void notifyAll()## Thread States and Transitions* New* Runnable* Running* Waiting/blocked/sleeping* Dead## Preventing Thread Execution* Sleeping* Waiting* Blocked because it needs an object's lock## Sleeping* The sleep() method is a static method of class Thread, it puts the currently running thread to sleep## Thread Priorities and yield()* The lower-priority running thread usually will be bumped back to runnable and the highest-priority thread will be chosen to run* In most cases, the running thread will be of equal or greater priority than the highest priority threads in the pool* Thread-scheduling priority behavior is not guaranteed* A scheduler might do one of the following:* Pick a thread to run, and run it there until it blocks or completes* Time slice the threads in the pool to give everyone an equal opportunity to run## Setting a Thread's Priority* A thread gets a default priority that is the priority of the thread of execution that creates it* Use setPriority() on a Thread instance* Thread.MIN_PRIORITY		(1)* Thread.NORM_PRIORITY		(5)* Thread.MAX_PRIORITY		(10)## The yield() Method* yield() make the currently running thread head back to runnable* There's no guarantee the yielding thread won't just be chosen again over all the others## The join() Method* The non-static join() method of class Thread lets one thread “join onto the end” of another thread* **A call to sleep()**	Guaranteed to cause the current thread to stop executing for at least the specified sleep duration* **A call to yield()**	Not guaranteed to do much of anything, although typically it will cause the currently running thread to move back to runnable* **A call to join()**	Guaranteed to cause the current thread to stop execution until the thread it joins with completes## Synchronizing Code* You can't guarantee that a single thread will stay running throughout the entire atomic operation## Synchronization and Locks* Only methods (or blocks) can be synchronized, not variables or classes* Each object has just one lock* Not all methods in a class need to be synchronized. A class can have both synchronized and non-synchronized methods* If two methods are about to execute a synchronized method in a class, and both threads are using the same instance of the class to invoke the method, only one thread at a time will be able to execute the method. In other words, once a thread acquires the lock on an object, no other thread can enter any of the synchronized methods in that class* If a class has both synchronized and non-synchronized methods, multiple threads can still access the class's non-synchronized methods* If a thread goes to sleep, it holds any locks it has – it doesn't release them* A thread can acquire more than one lock. The thread is free to call other synchronized methods on the same object, using the lock the thread already has* You can synchronize a block of code rather than a method## So What About Static Methods? Can They Be Synchronized?* Static methods can be synchronized## What Happens If a threads Can't Get the Lock?* Threads calling non-static synchronized methods in the same class will only block each other if they're invoked using the same instance* Threads calling static synchronized methods in the same class will always block each other – they all lock on the same Class instance* A static synchronized method and a non-static synchronized method will not block each other, ever* For synchronized blocks, you have to look at exactly what object has been used for locking. Threads that synchronize on the same object will block each other. Threads that synchronize on different objects will not## So When Do I Need To Synchronize?* Methods that access changeable fields need to be synchronized* Access to static fields should be done from static synchronized methods* Access to non-static fields should be done from non-static synchronized methods## Thread-Safe Classes* Don't rely on Collections.synchronizedList()## Thread Deadlock## Thread Interaction* wait(), notify(), and notifyAll() must be called from within a synchronized context! A thread can't invoke a wait or notify method on an object unless it owns that object's lock* If the thread calling wait()  does not own the lock, it will throw an IllegalMonitorStateException* wait(millis)	: if the thread is not interrupted, it will continue normally whenever it is notified or the specified timeout has elapsed## Using notifyAll() When Many Threads May Be Waiting* notifyAll(); 	// Will notify all waiting threads## Using wait() in a Loop* When you use wait() and notify() or notifyAll(), you should almost always also have a while loop around the wait() that checks a condition and forces continued waiting until the condition is met