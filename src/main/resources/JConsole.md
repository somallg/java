# Using JConsole## JConsole is a JMX-compliant (Java Management Extensions)* JConsole provide information on performance and resource consumption## Starting jConsole* Run jConsole (in JDK_HOME/bin)## Command Syntax* You can use jConsole to monitor both local applications and remove applications* Local monitoring: jConsole [processID] ( jConsole 2956)* Remote monitoring: jConsole [hostName:portNum]## Connecting to a JMX Agent* Start jConsole => Connection | New Connection* Local Tab: lists any JVMs running on the local system* Remove Tab: connection to JVM running on different system* Advanced Tab: connect to other JMX agents by specifying their JMX URL## The jConsole interface* jConsole interface is composed of 6 tabs:* Summary tab* Memory tab* Threads tab* Classes tab* Mbeans tab* VM tab## Summary* Uptime: how long the JVM has been running* Total compile time: the amount of time spent in the JIT compilation* Process CPU time: the total amount of CPU time consumed by the JVM## Threads* Live threads: Current number of live daemon threads + non-daemon threads* Peak: Highest number of live threads since JVM started* Daemon threads: Current number of live daemon threads* Total started: Total number of threads since JVM started## Memory* Current heap size: Number of KBytes currently occupied by the heap* Committed memory: Total amount of memory allocated for use by the heap* Maximum heap size: Maximum number of KBytes occupied by the heap.* Objects pending for finalization: Number of objects pending for finalization* Garbage collector information: Information on GC, including the GC names, number of collections performed, and total time spent performing GC## Classes* Current classes loaded: Number of classes currently loaded into memory* Total classes loaded: Total number of classes loaded into memory since JVM started* Total classes unloaded: Number of classed unloaded since JVM started## Operating System* Total physical memory: Amount of RAM that the OS has* Free physical memory: Amount of free RAM the OS has* Committed virtual memory: Amount of virtual memory guaranteed to be available to the running process## Monitoring Memory Consumption* Provides information on memory consumption and memory pools* The memory pools available depend on the JVM. For HotSpot JVM, the pools are:* Eden Space (heap): poole for most objects* Survivor Space (heap): pool containing objects that have survived GC of eden sapce* Tenured Generation (heap): containing objects that have existed for some time in survivor space* Permanent Generation (non-heap): holds all the reflective data, such as class and method objects* Code Cache (non-heap): containing memory used for compilation and storage native code## Heap and Non-heap Memory* JVM manages 2 kind of memory: heap and non-heap, both created when it starts* Heap memory: runtime data area for classes instances and arrays.GC reclaims heap memory from objects* Non-heap memory: includes method-area and memory. Its store per-class structures such as runtime constant pool, field and method data, and the code for methods and constructors## Memory Pools and Memory Managers* Memory pool: a memory area that JVM manages (String pool)* Memory manager: manages one or more memory pools. GC is a type of memory manager## Garbage Collection* GC is the process of releasing memory* HotSpot VM GC uses generational garbage collection:* many objects have short lives (iterators, local variables)* some objects have very long lifetimes* GC divides memory into several generations, and assigns each a memory pool* HotSpot VM defines 2 generations: young generation and old generation