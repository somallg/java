# SCJP 5 - Chapter 6 Strings, I/O, Formatting, and Parsing## String, StringBuilder, and StringBuffer* StringBuilder has exactly the same methods as the old StringBuffer## The String Class* Strings are immutable objects, String reference variables are not* If you create a new String without assigning it, it will be lost to your program* If you redirect a String reference to a new String, the old String can be lost* String methods use zero-based indexes, except for the second argument of substring()* String class is final – its methods can't be overridden* String have method : length(), arrays have an attribute named length## Important Facts About Strings and Memory* JVM sets a special area of memory called the “Spring constant pool”* When JVM finds a String literal, it is added to the String literal pool## Important Methods in the String class* charAt()* concat()* equalsIgnoreCase()* length()* replace()* substring()* toLowerCase()* toString()* toUpperCase()* trim()## The StringBuffer and StringBuilder Classes* StringBuffer vs StringBuilder : same API* StringBuilder is not thread safe* StringBuilder methods should run faster than StringBuffer methods* They are mutable – can be change without creating a new object* StringBuffer methods act on the invoking object, and objects can change without an explicit assignment in the statement* StringBuffer equals() is not overridden; it doesn't compare values* Chained methods are evaluated from left to right## Important Methods in the StringBuffer and StringBuilder Classes* public synchronized StringBuffer append(String s)* public StringBuilder delete(int start, int end)* public StringBuilder insert(int offset, String s)* public synchronized StringBuffer reverse()* public String toString()## File Navigation and I/O* File : an abstract representation of file and directory pathname. The File class isn't used to actually read or write data; it's used to work at a higher level, making new files, searching for files, deleting files, making directories, and working with paths* FileReader : this class is used to read character files. Its read() read single character, whole stream of characters, or a fixed number of characters* BufferedReader : make Reader more efficient, read large chunks of data from a file at once, and keep this data in a buffer. BufferedReader provides readLine()* FileWriter : write() methods allow to write character(s) or Strings to a file* BufferedWriter : write large chunks of data to a file at one. BufferedWriter provides newLine() method* PrintWriter : new methods like format(), print(), and append()* Stream classes are used to read and write bytes, Readers and Writers are used to read and write characters## Creating Files Using Class File* File represent the actual files or directories that exist on a computer's physical disk* boolean exists() : return true if it can find the actual file* boolean createNewFile() : create a new file if it doesn't exists## Using FileWriter and FileReader* close() after done with file* flush() to make sure the data is pushed to the file## Combining I/O classes* java.io Mini API* I/O classes can be chained## Working with Files and Directories* readLine() return null if there is no more data to read* no flush() in Reader classes* File.list() return String[] of files and directories## Serialization* Save object and all of its instance variables## Working with ObjectOutputStream and ObjectInputStream* ObjectOutputStream.writeObject() // serialize and write* ObjectInputStream.readObject() // read and deserialize## Object Graph* Java serialization mechanism take care of saving the object's entire “object graph”* Object inside need to implements Serializable* The serialization will skip the instance variable that marked as transient## Using writeObject and ReadObject* private void writeObject(ObjectOutputStream os)* private void readObject(ObjectInputStream is)* call defaultWriteObject and defaultReadObject* When you read back, you have to read the extra stuff in the same order you wrote it* Runtime specific object cannot be serialized I.e streams, threads, runtime, GUI classes...## How Inheritance Affects Serialization* If you are a serializable class, but your superclass is NOT serializable, then any instance variables you INHERIT from that superclass will be reset to the values they were given during the original construction of the object* If you serialize a collection or an array, every element must be serializable* Collection interfaces are not serializable, the concrete collection classes in Java API are## Serialization Is Not for Statics* Static variables are NEVER saved as part of the object's state...because they do not belong to the object!## Dates, Numbers, and Currency* java.util.Date (most methods in this class have been deprecated, use this to bridge between Calendar and DateFormat)* java.util.Calendar (convert and manipulate dates and times)* java.text.DateFormat (provide various styles)* java.text.NumberFormat (format numbers and currencies for locales)* java.util.Locale (used in conjunction with DateFormat, NumberFormat to format dates, numbers and currency for specific locales)## Orchestrating Date- and Number- Related Classes* Get the current date and time : Date d = new Date(); String s = d.toString();* Get an object that lets you perform date and time calculations in your locale : Calendar c = Calendar.getInstance(); c.add(..) and c.roll(...)* Perform date and time calculations in different locale : Local loc = new Locale(language) or Locale locl = new Locale(language, country); Calendar c = Calendar.getInstance(loc); use c.add() or c.roll()## The Date Class* DEPRECATED , use Calendar instead of Date* quick way to get current time or universal time* date and time is store as a primitive long (number of milliseconds)* To get current time : Date now = new Date();## The Calendar Class* Calendar is abstract class : Calendar c = new Calendar; // Error* use getInstance() : Calendar cal = Calendar.getInstance();## The DateFormat Class* DateFormat is abstract class## The Locale Class* locale is a specific geographical, political, or cultural region* Two Locale constructors : Locale(String language); Locale(String language, String country)* language argument represents an ISO 639 language code* CANNOT change the locale of an existing instance* The NumberFormat Class* abstract class* use getInstance() or getCurrencyInstance()## Parsing, Tokenizing, and Formatting* Finding stuff* Tokenizing stuff* Formatting stuff## A Search Tutorial## Tokenizing* Tokenizing is the process of taking big pieces of source data, breaking them into little pieces, and storing the little pieces in variables* 2 classes in the API that provide tokenizing capabilities : String (use split()) and Scanner## Token and Delimiters* Data that starts out composed of 2 things: tokens and delimiters* Tokens are the actual pieces of data, and delimiters are the expressions that separate the tokens from each other* Delimiters can be anything that qualifies as a regex expression## Tokenizing with String.split()* split() method takes a regex expression as its argument, returns a String array populated with the tokens produced by the split process* Handy way to tokenize relatively small pieces of data* Drawback : can't doing on-the-fly tokenizing operations## Tokenizing with Scanner* Scanner can be constructed using files, stream, or String as a source* Tokenizing is performed within a loop so that you can exit the process at anypoint* Tokens can be converted to their appropriate primitive types automatically* useDelimiter() to set the delimiter## Formatting with printf() and format()* format() and printf() behave exactly the same way* format() use java.util.Formatter to do the heavy formatting work* printf(“format string”, argument(s));* formatting data will always start with a percent sign (%)* %[arg_index$][flags][width][.precision]conversion char* The values with [ ] are optional* 2$ ~ 2nd argument, 1$ ~ 1st argument* **arg_index**: an integer follow directly by a $, indicates which argument should be printed in this position* **flags**:    * “_” left justify this argument    * “+” include a sign (+ or -) with this argument    * “0” pad this argument with zeroes    * “,” Use locale-specific grouping separators    * “(“ enclose negative number in parentheses* **width** indicates the minimum number of characters to print* **precision** indicates the number of digits to print after the decimal point* **conversion** the type of argument you'll be formatting :    * b boolean    * c char    * d integer    * f floating point    * s string* If you have mismatch between the type specified in your conversion character and your argument, you'll get a runtime exception : System.out.format(“%d”, 12.3);