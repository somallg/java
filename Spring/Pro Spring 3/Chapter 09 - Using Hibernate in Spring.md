# Chapter 09 - Using Hibernate in Spring
* ORM - close the gap between the relational data structure in the RDBMS and the OO model in Java

## Sample Data Model

## Configuring Hibernate SessionFactory
* The core concept of Hibernate is based on the *Session* interface, which is obtained from the *SessionFactory*
* Main configurations:
    * *The dataSource bean*
    * *The transactionManager bean* - hibernate session factory requires a transaction manager for transactional data access
    * *Component scan*
    * *Hibernate SessionFactory bean*

## ORM Mapping Using Hibernate Annotations
* Two approaches to the mappings:
    * Design the object model first and then generate the DB scripts based on the object model (hibernate.hbm2dll.auto to have Hibernate automatically export the schema DDL to the database)
    * Start with the data model first and then model the POJOs with the desired mappings => more control on the data model, which is very useful in optimizing the performance of data access

// TODO add imsage

## Sample Mappings
* @Entity - mapped entity class
* @Table - define table name in the database that this entity was being mapped to
* @Column
* @Temporal with TemporalType.DATE - map the data type from the Java date type (java.util.Date) to the SQL data type (java.sql.Date)
* @Id - primary key of the object
* @GeneratedValue - tells Hibernate how the id value was generated. 
    * IDENTITY - the id was generated by the backend
* @Version - introducts Hibernate that we would like to use optimistic locking mechanism, using the *version* attribute as a control. Everytime Hibernate updates a record, it will compare the version of the entity instance to that of the record in the database
    
## One-to-Many Mapping
* @OneToMany
    * *mappedBy* attribute indicates the property in the *ContactTelDetail* class that provides the association (i.e linked up by the foreign key definition)
* @ManyToOne

## Many-to-Many Mappings
* Requires a join table
* @ManyToMany
* @JoinTable - indicate the underlying join table that Hibernate should look for
    * *joinColumns* defines the column that is the FK to CONTACT table
    * *inverseJoinColumns* defines the column that is the FK to the other side of the association

## The Hibernate Session Interface
* The major interface you need to deal with is the *Session* interface
* Declare DAO class as a Spring bean with data access logic using the *@Repository* annotation
* @Trasanctional - defines the transaction requirements
* SessionFactory - injected using *@Resource*

## Database Operations with Hibernate

## Query Data Using Hibernate Query Language
* Engineered around the object model
* After the mapping are defined, we don't need to construct SQL to interact with the database
* Use HQL instead of SQL

## Simple Query with Lazey Fetching
* By default, Hibernate will fetch the associations *lazily*, which mean that Hibernate will not join the association tables for records

## Query with Associations Fetching
* Set fetch=FetchType.EAGER - impact performance
* Force Hibernate to fetch the associated records in the query when required
    * With *Criteria*, use Criteria.setFetchMod()
    * With *NamedQuery*, use *fetch* operator to intruct Hibernate to fetch the association eagerly
* NamedQuery can be externalized into an XML file or declared using annotation in the entity class

## Inserting Data
* Just need to invoke the *Session.saveorUpdate* method, use for both insert and update

## Updating Data
* saveorUpdate

## Deleting Date
* *Session.delete* method

## Considerations of Using Hibernate
* Once all the object-to-relational mapping, associations, and queries are properly defined, Hibernate can provide an environment for you to focus on programming with the object model, rather than composing SQL statement for each operation
* Be careful when defining the mappings, especially the associations and their fetching strategy - observe the SQL statements generated by Hibernate to verify that all perfomrs as you expect
*
