# The Power of Filters
* Objectives - Filters

## Enhancing the entire web application

## How about some kind of "filter"?
* Filters are Java components - very similar to servlets - that you can use to intercept and process request *before* they are sent to the Servlet, or to process response *after* the servlet has completed, but *before* the response goes back to the client
* The Container decides when to invoke your filters based on declarations in the DD
* In the DD, the deployer maps which filters will be called for which request URL patterns
* Fun things to do with Filters
    * Request filters can
        * perform security checks
        * reformat request headers and bodies
        * audit or log requests
    * Response filters can
        * compress the response stream
        * append or alter the response stream
        * create a different response altogether
* There is only ONE filter interface, Filter

## Filters are modular, and configurable in the DD
* Filters can be chained together, to run one after the other. Filters are designed to be totally self-contained

## Three ways filters are like servlets
* The Container knows their API
* The Container manages their lifecycle
* They're declared in the DD

## A filter's life cycle
* Every filter must implement the three methods in the Filter interface: *init()*, *doFilter()*, and *destroy()*
* First there's *init()*
* *doFilter()* does the heavy lifting. The method takes three arguments:
    * ServletRequest
    * ServletResponse
    * FilterChain
* In the end there's *destroy()*

## Think of filter as being "stackable"
* This "conceptual stack" is just a way to think about filter chain invocations. We don't know how the Container actually implements this - but thinking of it this way lets you predict how your filters chain will behave

## Declaring and ordering filters
* When you configure filters in the DD, you'll usually do three things:
    * Declare your filter
        * <filter>
            * <filter-name> mandatory
            * <filter-class> mandatory
            * <init-param> optional
    * Map your filter to the web resources you want to filer
        * <filter-mapping>
            * <filter-name> mandatory and its used to link to the correct <filter> element
            * Either the <url-pattern> or the <servlet-name> element is mandatory
            * <url-pattern> element defines which web app resource will use this filter
            * <servlet-name> element defines which single web app resource will use this filter
    * Arrange these mappings to create filter invocation sequences
* IMPORTANT: The Container's rules for ordering filters: When more than one filter is mapped to a given resource, the Container uses the following rules:
    * ALL filters with matching URL patterns are located first. Filters with matching URL patterns are placed in the chain in the order in which they are declared in the DD
    * Once all filters with matching URLs are placed in the chain, the Container does the same thing with filters that have a matching <servlet-name> in the DD
    
## News Flash: As of version 2.4, filters can be applied to request dispatchers
* Declaring a filter mapping for request-dispatcher web resources
    * <dispatcher>
* Declaration Rules
    * The <filter-name> is mandatory
    * Either the <url-pattern> or <servlet-name> element is mandatory
    * You can have from 0 to 4 <dispatcher> elements
    * A REQUEST value activates the filter for client request. If no <dispatcher> element is present, REQUEST is the default
    * AN INCLUDE value activates the filter for request dispatching from an include() call
    * A FORWARD value activates the filter for request dispatching from a forward() call
    * An ERROR value activates the filter for resource called by the error handler

## Compressing output with a response-side filter
* The filter gets another shot at this *after* the servlet completes its work and is popped off the (virtual) stack!

## Architecture of a response filter

## Wrappers rock
* Four "convenience" classes wrapper:
    * ServletRequestWrapper
    * HttpServletRequestWrapper
    * ServletResponseWrapper
    * HttpServletResponseWrapper
* Whenever you want to create a custom request or response object, just subclass one of the convenience request or response "wrapper" classes
* A wrapper wraps the REAL request and response object, and delegates (passes through) calls to the real thing, while still letting you do the extra things you need for your custom request or response

## Mock exam
1 B D
2 E
3 E
4 D 
5 A D G
6 C
