# 14. Enterprise Design Patterns
* Objectives - J2EE Patterns

## Web site hardware can get complicated
* Most of the software for a big web application lives in either the "Web Tier" or the "Business Tier"
* Adding more computers to a tier is known as *horizontal scaling*, and is considered one of the best ways to increase throughput

## Lucky for us, we have J2EE patterns
* A software design pattern is "a repeatable solution for a commonly-occurring software problem"

## Performance
* Three of the most important non-functional requirements you're likely to face:
    * Performance
    * Modularity
    * Flexibility, Maintainability, and Extensibility
 
## Aligning our vernaculars...
* Code to interfaces 
* Separation of Concerns & Cohesion
* Hide Complexity

## More design principles...
* Loose Coupling
* Remote Proxy
* Increase Declarative Control

## Patterns to support remote model components

## How will they handle remote objects?
* JNDI and RMI, a quick overview
    * *locating* remote objects
    * handling all the low level network/IO *communications*
    * In other words, how to *find* remote objects, and how to *invoke* their methods
* JNDI in a nutshell
    * Java Naming and Directory Interface - an API to access naming and directory services
    * JNDI gives a network a centralized location to find things
    * Other client component only need to know how to find JNDI, without knowing where the objects *registered* with JNDI are actually located
* RMI in a nutshell
    * Remote Method Invocation, a mechanism that greatly simplifies the process of getting objects to communicate across a network
    
## RMI makes life easy
* RMI gives you - the ability to pretend that you're making a regular old local method call
* What we want...
    * An object in on JVM to cause a method invocation on a *remote* object, but you want to *pretend* that you're invoking a method on a *local* object
* How RMI pulls it off
    * Create a *proxy* and *register* your object with some sort of registry
    * Any client who wants to call your methods will do a lookup on the registry and get a copy of the remote *proxy*
    * Then client will make calls on the remote proxy, *pretending it's the real thing*
    * The remote proxy (called a *stub*), handles all the communications details like sockets, I/O streams, TCP/IP, serializing and deserializing method arguments and return values, handling exceptions, and so forth 
    * There's usually a proxy on the server side called *skeleton*, doing similar chores on the server side

## Just a little more RMI review
* RMI on the Server side in 4 steps
    * Create a *remote interface*
    * Create the *remote implementation*
    * Generate the stub and skeleton
    * Start/run the model service

## Adding RMI and JNDI to the controller
* 3 steps to using a remote object
    * Register the model component with JNDI service
    * Does a JNDI *lookup* to get the stub proxy
    * Makes business method calls against the stub
    
## How about a "go-between" object?
* Problem 1: Hide the complex JNDI lookup
* Problem 2: Hide "remote-ness complexity"

## The "go-between" is a Business Delegate

## Simplify your Business Delegates with the Service Locator
* To implement a Service Locator, we'll take all of the logic for doing the JNDI lookup and move it *out* of the multiple Business Delegates and *into* a single Service Locator
* By making the *Business* Delegate an object that handles only the *business* methods rather than *also* handling the registry lookup code, you increase the cohesion for the Business Delegates

## Protecting the web designer's JSPs from remote model complexity

## Compare the local model diagram to this remote model diagram
* Every time the JSP invokes a getter, the Customer stub makes a network call

## There's good news and bad news...
* The good news: succeeds in hiding complexity from both the controllers sand the JSPs
* The bad news
    * All these fine-grained network calls are likely to be a big performance hit
    * The JSP is NOT a good place to be handling exceptions that might occur if the remote server crashes
    
## Time for a Transfer Object?
* Commonly, the business service creates a serializable Java object that contains lots of instances variables
* Sun calls this object a *Transfer Object*
* Outside of Sun there is a pattern called *Data Transfer Object*
* The data in a Transfer Object grows stale!

## Our very first pattern revisited... MVC
* MODEL - Holds the real business logic and the state. In other words, it knows the rules for getting and updating state. It's the only part of the application that talks to the database
* CONTROLLER - takes user input from the request and figures out what it meas to the model
* VIEW - responsible for the presentation

## MVC in a real web app

## Is Struts a container?
* Top five ways Struts is like a servlets container
    * Declarative
    * Lifecycle
    * Callbacks
    * APIs
    * Application Control

## How does Front Controller fit in?
* The basic idea of the Front Controller pattern is that a single component, usually a servlet but possibly a JSP, acts as the single control point for the presentation tier of a web application
* With the Front Controller pattern, all of the app's request go through a single controller, which handles dispatching the request to the appropriate places
* Eight features that Struts adds to a Front Controller
    * Declarative Control: Struts allows you to create declarative maps between request URLs, validation objects, model-invoking objects, and views
    * Automated Request Dispatching: The Action.execute() method returns a symbolic ActionForward which tells the ActionServlet which view to dispatch to. This provides another layer of abstraction (and loose coupling) between the controller and view components
    * DataSources
    * Custom Tags
    * Internationalization Support
    * Declarative Validation
    * Global exception handling
    * Plug-ins

## The Struts Beer app architecture

## Patterns review for the SCWCD

### Business Delegate
* Use the Business Delegate pattern to shield your web tier controllers from the fact that some of your app's model components are remote
* Business Delegate features
    * Acts as a proxy, implementing the remote service's interface
    * Initiates communications with a remote service
    * Handles communication details and exceptions
    * Receives requests from a controller component
    * Translates the request and forwards it to the business service (via the stub)
    * Translates the response and returns it to the controller component
    * By handling the details for remote component lookup and communications, allows controllers to be more cohesive
* Business Delegate principles
    * The Business delegate is based on:
        * hiding complexity
        * coding to interface
        * loose coupling
        * separation of concerns
    * Minimizes the impact on the web tier when changes occur on the business tier
    * Reduces coupling between tiers
    * Adds a layer to the app, which increase complexity
    * Method calls to the Business Delegate should be coarse-grained to reduce network traffic
    
### Service Locator
* Use the Service Locator pattern to perform registry lookups so you can simplify all of the other components (such as Business Delegates) that have to do JNDI (or other registry types) lookups
* Service Locator features
    * Obtains InitialContext objects
    * Performs registry lookups
    * Handles communication details and exceptions
    * Can improve performance by caching previously obtained references
    * Works with variety of registries such as: JNDI, RMI, UDDI, and COS naming
* Service Locator principles
    * The Service Locator is based on:
        * hiding complexity
        * separation of concerns
    * Minimizes the impact on web tier when remote components change locations or containers
    * Reduce coupling between tiers

### Transfer Object
* Use the Transfer Object pattern to minimize network traffic by providing a local representation of a fine-grained remote component (usually an entity)
* Transfer Object functions
    * Provides a local representation of a remote entity (i.e, an object that maintains some data state)
    * Minimizes network traffic
    * Can follow Java bean conventions so that it can be easily accessed by other objects
    * Implemented as a serializable objects so that it can move across the network
    * Typically easily accessible by view components
* Transfer Object principles
    * The Transfer Object is based on:
        * reducing network traffic
    * Minimizes the performance impact on the web tier when remote component's data is accessed with fine-grained calls
    * Reduce coupling between tiers
    * A drawback is that components accessing the Transfer Object can receive out-of-date data, because the Transfer Object's data is really representing state that's stored somewhere else
    * Making updatable Transfer Object concurrency-safe is typically complex
    
### Intercepting Filter
* Use the Intercepting Filter pattern to modify requests being sent to servlets, or to modify responses being sent to users
* Intercepting Filter functions
    * Can intercept and/or modify requests before they reach the servlet
    * Can intercept and/pr modify response before they are returned to the client
    * Filters are deployed declaratively using the DD
    * Filters are modular so that they can be executed in chains
    * Filters have lifecycle managed by the Container
    * Filters must implement Container callback methods
* Intercepting Filter principles
    * The Intercepting Filter is based on:
        * cohesion
        * loose coupling
        * increase declarative control
    * Declarative control allows Filters to be easily implemented on either a temporary or permanent basis
    * Declarative control allows the sequence of invocation to be easily updated
    
### Model, View, Controller (MVC)
* Use the MVC pattern to create a logical structure that separates the code into three basic types of components (Model, View, Controller) in your application. This increases the cohesiveness of each component and allows for greater reusability, especially with model components
* Model, View, Controller features
    * Views can change independently from controllers and models
    * Model components hide internal details (data structures), from the view and controller components
    * If the model adheres to a strict contract (interface), then these components can be reused in other application areas such as GUIs or J2ME
    * Separation of model code from controller code allows for easier migration to using remote business components
* Model, View, Controller principles
    * Model, View, Controller is based on:
        * separation of concerns
        * loose couplings
    * Increases cohesion in individual components
    * increases the overall complexity of the application (This is true because even though individual components become more cohesive, MVC adds many new components to the application)
    * Minimizes the impact of changes in other tiers of the application

### Front Controller
* Use the Front Controller pattern to gather common, often redundant, request processing code into a single component. This allows the application controller to be more cohesive and less complex
* Front Controller features
    * Centralizes a web app's initial request handling tasks in a single component
    * Using the Front Controller with other patterns can provide loose coupling by making presentation tier dispatching declarative
    * A drawback of Front Controller (on its own, without struts) is that it's very barebones compared to Struts. To create a reasonable application from scratch using the Front Controller pattern, you would end up rewriting many of the features already found in Struts
* Font Controller principles
    * The Front Controller is based on:
        * hiding complexity
        * separation of concerns
        * loose coupling
    * Increase cohesion in application controller components
    * Decreases the overall complexity of the application
    * Increases the maintainability of the infrastructure code
    
## Mock exam
1 C
2 E
3 C
4 A
5 E
6 A
7 C
8 D
9 B