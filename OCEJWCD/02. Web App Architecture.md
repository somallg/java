# 2. Web app architecture
* Objectives
    * 1.1 For each of the HTTP Methods (such as GET, POST, HEAD, and so on), describe the purpose of the method and the technical characteristics of the HTTP method protocol, list triggers that might cause a client (usually a Web browser) to use the Method, and identify the HttpServlet method that corresponds to the HTTP Method
    * 1.4 Describe the purpose and event sequence of the servlet life cycle: (1) servlet class loading, (2) servlet instantiation, (3) call the init method, (4) call the service method, and (5) call the destroy method
    * 2.1 Construct the file and directory structure of a Web Application that may contain (a) static content, (b) JSP pages, (c) servlet classes, (d) the deployment descriptor, (e) tag libraries, (f) JAR files, and (g) Java class files; and describe how to protect resource files from HTTP access
    
## What does the Container give you?
* Communications support: The container provides an easy way for your servlets to talk to your web server. You don't have to build a SeverSocket, listen on a port, create a stream, etc... The container knows the protocol between the web server and itself, so that your servlet doesn't have to worry about an API between, the Apache web server and your own web application code
* Lifecycle Management: The container controls the life and death of your servlets. It takes care of loading the classes, instantiating ans initializing the servlets, invoking the servlet methods, and making the servlets instances eligible for GC. You don't have to worry about resource management
* Multithreading Support: The container automatically creates a new Java thread for every servlet request it receives. When the servlet's done running the HTTP service method for that client's request, the thread completes (i.e dies)
* Declarative security: With a Container, you get to use an XML deployment descriptor to configure (and modify) security without having to hard-code it into your servlet (or any other) class code
* JSP Support: The container takes care of translating JSP code into real Java
    
## DD Benefits
* Minimizes touching source code that has already been tested
* Lets you fine-tune your app's capabilities, even if you don't *have* the source code
* Lets you adapt your application to different resources (like databases), without having to recompile and test any code
* Makes it easier for you to maintain dynamic security info like access control lists and security roles
* Lets non-programmers modify and deploy your web applications while *you* can focus on the more interesting things

## Bullet Points
* The container gives your web app communications support, lifecycle management, multithreading support, declarative security, and supports for JSPs, so that you can concentrate on your own business logic
* The Container creates a request and response object that servlets (and other parts of the web app) can use to get information about the request and send information to the client
* A typical servlet is a class that extends *HttpServlet* and overrides one or more service methods that correspond to HTTP methods invoked by the browser (*doGet()*, *doPost()*, etc..)
* The deployer can map a servlet class to a URL that the client can use to request that servlet. The name may have nothing to do with the actual class *file* name
