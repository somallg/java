# 8. Script-free pages
* Objectives - Building JSP pages using the Expression Language (EL) and Standard Actions

## Our MVC app depends on attributes

## Can you make polymorphic bean references?
* When you write a <jsp:useBean>, the *class* attribute determines the class of the new *object* (if one is created). It also determines the type of the *reference* variable used in the generated servlet
* The class attribute in that tag represents both the reference AND object type
* But... what if we want the reference type to be *different* from the actual object type?

## Adding a type attribute to <jsp:useBean>
* Type can be a class type, abstract type, or an interface
* The *class* must be a subclass or concrete implementation of the *type*

## Using type without class
* If *type* is used without class, the bean must already exist
* If *class* is used (with or without type) the class must NOT be abstract, and must have a public no-arg constructor
* If you use type without class, you better make CERTAIN that the bean is already stored as an attribute, at the *scope* and with the *id* you put in the tag

## The scope attribute defaults to "page"
* If you dont specify a scope in either the <jsp:useBean> or <jsp:getProperty> tags, the Container uses the default of "page"
* Don't confuse type with class!
* Be SURE that you remember:
    * type == reference type
    * class == object type
* Or to put it another way:
    * *type* is what you DECLARE (can be abstract)
    * *class* is what you INSTANTIATE (must be concrete)
    * type x = new class()

## Going straight from the request to the JSP without going through a servlet...

## The param attribute to the rescue
* The *param* attribute lets you set the value of a bean property to the value of a request parameter. JUST by naming the request parameter!
* The param value "userName" comes from the name attribute of the form input field

## But wait! It gets event better...
* And all you have to do is make sure you form *input field name* (which becomes the request parameter name) is the same as the *property name* in your bean. Then in the <jsp:setProperty> tag, you dont have to specify the *param* attribute
* If you name the *property* but don't specify a *value* or *param*, you are telling the Container to get the value from a *request parameter* with a matching name
* If the request parameter name matches the bean property name, you dont need to specify a value in the <jsp:setProperty> tag for that property

## If you can stand it, it gets even BETTER...

## Bean tags convert primitive properties automatically
* JavaBean properties *can* be *anything*, but if they're String or primitives, all the coercing is done for you
* That's right - you dont have to do the parsing and conversion yourself

## Automatic String-to-primitive conversion does NOT work if you use scripting!! It fails even if an expression is INSIDE the <jsp:setProperty> tag

## The bean standard action tags are more natural to a non-programmer
* Once again, the benefit of using tags over scripting is more about the web page designers than about *you* (the Java programmer)

## But what if the property is something OTHER than a String or primitive
* The <jsp:getProperty> lets you access *only* the properties of the bean attribute
* There's no capability for nested properties, where you want a property of a *property*, rather than a property of an *attribute*

## Expression Language (EL) saves the day!
* This:
    * ${person.dog.name} 
* Replaces this:
    * <%= ((Person) request.getAttribute("person")).getDog().getName %>

## Deconstructing the JSP Expression Language (EL)
* Think of EL as a way to access Java object *without using Java*
* EL expressions are ALWAYS within curly braces, and prefixed with the dollar sign
    * ${person.name}
* The first named variable in the expression is either an implicit object or an attribute
* EL IMPLICIT OBJECT
    * pageScope
    * requestScope
    * sessionScope
    * applicationScope
    * param
    * paramValues
    * header
    * headerValues
    * cookie
    * initParam
    * pageContext
* ATTRIBUTE
    * in page scope
    * in request scope
    * in session scope
    * in application scope
* EL implicit objects are not the same as the implicit objects available to JSP scripting, except for pageContext
* Only pageContext is not a map. It's an actual reference to the pageContext object
* If the first thing in the EL expression is an attribute, it can be the name of an attribute stored in any of the four available scope

## Using the dot (.) operator to access properties and map values
* If the expression has a variable followed by a dot, the left-hand variable MUST be a *Map* or a *bean*
* Thing on the *right* of the dot MUST be a Map *key* or a bean *property*
* And the thing on the *right* must follow normal Java naming rules for identifiers
    * Must start with a letter, _, or $
    * After the first character, you can include numbers
    * Can't be a Java keyword
* If the object is a bean but the named property doesn't exist, then a exception is thrown

## The [] operator is like the dot only way better
* The dot operator works only when the thing on the right is a bean property or map key for the thing on the left
* But the [] operator is a lot more powerful and flexible

## The [] gives you more options...
* If the expression has a variable followed by a bracket [], the left-hand variable can be a *Map*, a *bean*, a *List*, or an *array*
* If the thing *inside* the brackets is a String literal (i.e, in quotes), it can be a Map *key* or a bean *property*, or an *index* into a List or array

## Using the [] operator with an array

## A String index is coerced to an int for arrays and Lists
* The EL for accessing an *array* is the same as the EL for accessing a *List*
* If the thing to the left of the bracket is an array or a List, and the index is a String literal, the index is coerced to an int

## For beans and Maps you can use either operator

## If it's NOT a String literal, it's evaluated
* Find a attribute named "Ambient". Use the VALUE of that attribute as the key into the Map, or return null

## You can use nested expressions inside the brackets
* The expressions are evaluated from the inner most brackets out
* The tricky part is to watch out for quotes vs *no* quotes

## You can't do ${foo.1}
* With beans and Maps, you can use the dot operator, but only if the ping you type after the dot is a legal Java identifier

## EL renders raw text, including HTML

## The EL implicit objects
* EL has some implicit objects. But these are not the same as the JSP implicit objects (except for one, pageContext)
* You'll notice that all but on (pageContext), are simple Maps - name/value pairs
* A Map of the scope attributes
    * pageScope
    * requestScope
    * sessionScope
    * applicationScope
* Maps of the request parameters
    * param
    * paramValues
* Maps of the request headers
    * header
    * headerValues
* Map of cookie
    * cookie
* Map of the context init parameters
    * initParam
* pageContext

## Request parameters in EL
* Use paramValues when you might have more than one parameter for a given parameter name
* param is just a Map of parameter names and values. The things to the right of the dot come from the names specified in the input field of the form
* Even though there might be multiple values for a parameter, you can still use the single param implicit object, but you'll get only the first value

## What if you want more information from the request?
* Getting the "host" header
    * <%= request.getHeader("host") %>
    * ${header.host}
    * ${header["host"]}
* Getting the HTTP request method
    * <%= request.getMethod() %>

## The requestScope is NOT the request object
* The implicit requestScope is just a Map of the request scope attributes, not the request object itself
* What you want (HTTP method) is a *property* of the request object, not an attribute at request scope
* In other words, you want something that comes from calling a getter method on the request object
* Use requestScope to get request ATTRIBUTES, not request PROPERTIES. For request properties, you need to go through pageContext
* Use pageContext to get to everything else...
    * ${pageContext.request.method}
    * pageContext has a *request* property, *request* has a *method* property
* Don't confuse the Map scope objects with the objects to which the attributes are bound. The scope Map is just a Map of attributes, and nothing more

## Scope implicit objects can save you
* If all you need is to print the name of a *person*, and you really don't care what scope the *person* is in, just use:
    * ${person.name}
* If you're worried about a potential naming conflict, you can be explicit about which person you want:
    * {requestScope.person.name}
* But an attribute name is a String!
* Strings don't follow Java variable name rule!
* That means someone *could* say:
    * request.setAttribute("foo.person", p);
    * THIS won't work: ${foo.person.name}
* Using requestScope object gives us a way to put the attribute name in quotes, because using a scope object lets you switch to the [] operator that can take String names that don't conform to Java naming rules
    * ${requestScope["foo.person"].name}

## Getting Cookies and init params
* Printing the value of the *userName* Cookie
    * Using *scripting* is kind of a pain, because the request does NOT have a *getCookie(cookieName)* method! We have to get the whole Cookie array and iterate through it ourselves
    * But with EL, we've got the Cookie implicit object
        * ${cookie.userName.value}
* Printing the value of a *context init parameter*
    * We have to configure the parameter in the DD
    * In scripting: <%= application.getInitParameter("mainEmail") %>
    * With EL: ${initParam.mainEmail}
* The EL initParam is NOT for params configured using <init-param>!
* Here what's confusing: servlet init params are configured using <init-param> while context params use <context-param> but the EL implicit "initParam" is for *context* params

## Imagine you want your JSP to roll dice
* Write a Java class with a public static method
* Write a Tag Library Descriptor (TLD) file
    * For an EL function, the TLD provides a mapping between the Java class that *defines* the function and the JSP that *calls* the function. The *name* used in EL doesn't have to be the same as the actual method name, and the TLD is where you map that
* Put a taglib directive in your JSP
    * The taglib directive tells the Container, "I'm going the use this TLS, and in the JSP, when I want to use a function from this TLD, I'm going to prefix it with this name...". In other words, it lets you define the namespace. You invoke the function by giving both the function name AND the TLD prefix
* Use EL to invoke the function
    * Just call the function from a expression using ${prefix:name()}

## The function class, the TLD, and the JSP

## Deploying an app with static functions
* The TLD has to be somewhere within WEB-INF or one of its subdirectories
* The class with the function (the public static method) must be available to the web app just like servlet, bean and listener classes. Tha means somewhere in WEB-INF/classes...
* Remember that in the *taglib* directive in the JSP, we specified a URI that matches the URI declared in the TLD
* Think of the URI as simply *whatever you decided to name the TLD*
* Put the TLD file somewhere under WEB-INF, and make sure the taglib directive in the JSP includes a uri attribute that matches the <uri> element in the TLD
* Remember that the METHOD name does NOT have to match the FUNCTION name
* What you use in EL to invoke the function must match the <name> element in the <function> declaration in the TLD
* The element for <function-signature> is there to tell the Container which method to call when the JUST uses the <name>
* The only place the class name appears is in the <function-class> element
* Everything in the <function> tag has the word <function in it EXCEPT for the <name> tag

## And a few other EL operators...
* You probably won't (and *shouldn't*) do calculations and logic from EL
* Remember, a JSP is the View, and the View's job is to render the response, not to make Big Important Decisions or Big Processing
* But... for little things, somethings a little arithmetic or a simple boolean test might come in handy
* Arithmetic (5)
    * Addition: +
    * Subtraction: -
    * Multiplication: *
    * Division: / and div
    * Remainder: % and mod
* Logical (3)
    * AND: && and *and*
    * OR: || and *or*
    * NOT: ! and *not*
* Relational:
    * Equals: == and eq
    * Not equals: != and ne
    * Less than: < and lt
    * Greater than: > and gt
    * Less than or equal to: <= and le
    * Greater than or equal to: >= and ge
* Don't use EL reserved words as identifiers!

## EL handles null values gracefully
* EL is null-friendly. It handles unknown or null values so that the page still displays, even if it can't find an attribute/property/key with the name in the expression
* In arithmetic, EL treats the null value as "zero"
* In logical expression, EL treats the null value as "false"

## JSP Expression Language (EL) review
* El expressions are always within curly braces, and prefixed with a dollar($) sign ${expression}
* The first named variable in the expression is either an implicit object or an attribute in one of the four scopes (page, request, session, or application)
* The dot operator lets you access values by using a Map key or a bean property name, for example ${foo.bar} gives you the value of *bar*, where *bar* is the name of Map key into the Map *foo*, or *bar* is the property of bean *foo*. Whatever comes to the right of the dot operator must follow normal Java naming rules for identifiers! (In other words, must start with a letter, underscore, or dollar sign, can include numbers after the first character, but nothing else, etc.)
* You can NEVER put anything to the right of the dot that wouldn't be legal as a Java identifier. For example, you can't say ${foo.1}
* The [] operator is more powerful than the dot, because it lets you access arrays and Lists, *and* you can put other expressions including named variables within the brackets, *and* you can nest them to any level you can stand
* For example, if musicList is an ArrayList, you can access the first value in the list by saying ${musicList[0]} or ${musicList["0"]}. EL doesn't care if you put quotes around the list index
* If what's inside the brackets is not in quotes, the Container evaluates it. If it is in quote, and it's not an index into an array or List, the Container sees it as the literal name of a property or key
* All but one of the EL implicit objects are Maps. From the Map implicit objects you can get attributes from any of the four scopes, request parameter values, header values, cookie values, and context init parameter. The non-map implicit object is pageContext, which is a reference to... the PageContext object
* Don't confuse the implicit EL scope objects (Maps of the attribute) with the objects to which the attributes are bound. In other words, don't confuse the *requestScope* implicit object with the actual JSP implicit *request* object. The only way to access the request object is by going through the pageContext implicit object (Although some of what you might want from the request is already available through other EL implicit objects, including *param/paramValues*, *header/headerValues*, and *cookie*)
* EL function allow you to call a public static method in a plain old Java class. The function name does not have to match the actual method name! For example, ${foo:rollIt()} does not mean that there must be a method named rollIt() in a class that has a function
* The function name (e.g rollIt()) is mapped to a real static method using a TLD (Tag Library Descriptor) file. Declare a function using the *<function>* element, including the *<name>* of the function (rollIt()), the fully-qualified *<function-class>*, and the *<function-signature>* which includes the return type as well as the method name and argument list
* To use a function in a JSP, you must declare the namespace using a taglib directive. Put a *prefix* attribute in the taglib directive to tell the Container the TLD in which the function you're calling can be found. Example: <%@ taglib prefix="mine" uri="/WEB-INF/foo.tld" %>

## Reusable template pieces
* There's a mechanism for handling this in a JSP - it's called *include*

## The include directive
* The include directive tells the Container one thing: *copy* everything in the *included* file and *paste* it into *this* file, right *here*...
* <%@ include file="header.jsp" %>

## The <jsp:include> standard action
* <jsp:include> standard action *appears* to do the same thing as the include directive

## They're NOT the same underneath...
* The include directive just takes the contents of the file and places it into the page BEFORE it does the translation
* <jsp:include /> is different! the original jsp file is NOT inside the generated servlet. Instead, it's some kind of runtime call

## The include directive happens at translation time <jsp:include> happens at runtime
* With the *include* directive, there is NO difference between you opening your JSP page and pasting in the contents
* But <jsp:include> is completely different story. Rather than copying in the source code, the include *standard action* inserts the *response* at runtime. The key to <jsp:include> is that the Container is creating a RequestDispatcher from the page attribute and applying the *include()* method. The dispatched/included JSP executes against the same request and response objects, within the same thread
* The include *directive* inserts the SOURCE, at translation time
* But the <jsp:include> *standard action* inserts the RESPONSE, at runtime
* The attribute names are different for the include directive and <jsp:include/>
    * The directive attribute is *file*
    * But the standard action attribute is *page*
* The include directive is position-sensitive! It's the ONLY directive whose position in the JSP actually matters
* Do NOT put opening and closing HTML and BODY tags within your reusable pieces!
* Design and write your layout template chunks assuming they will be included in some OTHER page
* The idea of stripping out the opening and closing tags applies to BOTH include mechanism - <jsp:include> and the include directive

## Customizing the included content with <jsp:param>
* <jsp:include> can have a BODY, so that you add (or replace) request parameters that the included thing can use
* This idea of params doesn't make any sense with the include directive (which is not dynamic), so it applies ONLY to the <jsp:include> standard action
 
## A conditional forward...
* <jsp:forward> forward the request (just like using a RequestDispatcher) to the page specified in the attribute)

## With <jsp:forward>, the buffer is cleared BEFORE the forward
* NOTHING you write *before* the forward will appear if the forward happens
* When a forward happens, the resource to which the request is forwarded starts with a clean response buffer! In other words, anything written to the response before the forward happens is thrown out

## Bean-related standard action review
* The <jsp:useBean> standard action defines a variable that holds a reference to either an *existing* bean attribute or, if the bean doesn't already exist, a *new* bean
* The <jsp:useBean> MUST have an "id" attribute which declares the variable name that will be used in this JSP to refer to the bean
* If you don't include a "scope" attribute with <jsp:useBean>, the scope defaults to *page* scope
* The "class" attribute is optional, and it declares the class type that will be used if a new bean is created. The type must be public, non-abstract, and have a public no-arg constructor
* If you put a "type" attribute in <jsp:useBean>, it must be a type to which the bean can be cast
* If you have a "type" attribute but do NOT have a "class" attribute, the bean must already exist, since you haven't specified the class type that should be instantiated for the new bean
* The <jsp:useBean> tag can have a body, and anything in the body runs ONLY if a new bean is created as a result of <jsp:useBean> (which means that no bean with that "id" was found in the specified (or default) scope)
* The main purpose of the body of <jsp:useBean> is to set the new bean's properties, using <jsp:setProperty>
* <jsp:setProperty> must have "name" attribute (which will match the "id" from <jsp:useBean>), and a "property" attribute. The "property" attribute must be either an actual property name or the wildcard "*"
* If you don't include a "value" attribute, the Container will set the property value only if there's a request parameter with a name that matches the property name. If you use the wildcard (*) for the "property" attribute, the Container will set the value of all properties that have a matching request parameter name. (Other properties won't be affected)
* If the request parameter name is different from the property name but you want to set the value of the property equal to the request parameter value, you can use the "param" attribute in the <jsp:setProperty> tag
* The <jsp:setProperty> action uses introspect to match the "property" to a JavaBean setter method. If the property is "*", then the JSP will iterate over all request parameters to set the JavaBean properties
* Property values can be String or primitives, and the <jsp:setProperty> standard action will do the conversions automatically

## The include review
* You can build a page with reusable components using one of two include mechanisms - the include *directive* or the <jsp:include> *standard action*
* The include *directive* does the include at translation time, only once. So the include *directive* is considered the appropriate mechanism for including content that isn't likely to change after deployment
* The include *directive* essentially copies everything from within the included file and pastes it into the page with the include. The Container combines all the included files and compiles just one file for the generated servlet. At runtime, the page with the include runs exactly as though you had typed all the source into one file yourself
* The <jsp:include> *standard action* includes the response of the included page into the original page at runtime. So the include *standard action* is considered appropriate for including content that may be updated after deployment, while the include *directive* is not
 * Either mechanism can include dynamic elements (JSP code with EL expressions) as well as static HTML pages
* The include *directive* is the only position-sensitive directive; the included content is inserted into the page at the exact location of the directive
* The attributes for the include *directive* and the include *standard action* are inconsistently named - the *directive* uses "file" as the attribute while the *standard action* uses a "page" attribute
* In your reusable components, be sure to strip out the opening and closing tags. Otherwise, the generated output will have nested opening and closing tags, which not all browsers can handle. Design and construct your reusable pieces knowing that they'll be included/inserted into something else
* You can customize an included file by setting (or replacing) a request parameter using the <jsp:param> standard action inside the body of a <jsp:include>
* <jsp:param> can use inside the body of a <jsp:forward> as well
* The ONLY places where a <jsp:param> makes sense are within a <jsp:include> or a <jsp:forward> standard action
* If the param name used in <jsp:param> already has a value as a request parameter, the new value will overwrite the previous one. Otherwise, a new request parameter is added to the request
* The included resource has some limitations: it cannot change the response status code or set headers
* The <jsp:forward> standard action forwards the request (just like using a RequestDispatcher) to another resource from the same web app
* When a forward happens, the response buffer is cleared first! The resource to which the request was forwarded gets to start with a clean output. So anything written to the response *before* the forward will be thrown away
* If you commit the response *before* the forward (by calling out.flush()), the client will be sent whatever was flushed, but that's it. The forward won't happen, and the rest of the original page won't be processed

1 A C
2 C
3 B 
4 C
5 A
6 B D F
7 B C F
8 A
9 B
10 B D E G
11 D E
12 C
13 E
14 E
15 C F
16 B
17 A
18 C
19 B 
20 C
