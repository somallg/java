# SCJP 5 - Chapter 5 Flow Control, Exceptions, and Assertions## if and switch Statements* if () must evaluate to (a boolean) true or false## if-else Branching* You can have zero or one else's for a given if, and it must come after any else if's* You can have zero to many else if's for a given if and they must come before the (optional) else* Once an else if success, none of the remaining else if or else's will be tested## Legal Expressions for if Statements* The expression in an if statement must be a boolean expression## switch Statements* Provide a way to simulate the use of multiple if statements## Legal Expressions for switch and case* A switch's expression must evaluate to a char, byte, short, int, or as of Java 5, an enum, i.e only variable and values that can be automatically promoted to an int are acceptable ( except for enum)* A case constant must evaluate to the same type as the switch expression, the case constant must be a compile time constant ( constant or final variable assigned a literal value)* It it no enough to be final, it must be a compile time constant* Error => If the case constant is out of range of the switch's expression* Error => If the case have duplicate value## Break and Fall-Through in switch Blocks* case constants are evaluated from top down, and the first case constant that matches the switch's expression is the execution entry point## The Default Case* Default case works just like any other case for fall-through* Default case doesn't have to come at the end of the switch## Loops and Iterators* Java loops come in 3 flavors: while, do, for (as of Java 5, for-each)## Using while Loops* While loop is good when you don't know how many times a block or statements should repeat, but you want to continue looping as long as some condition is true* Variable used in the expression of while loop must be declared## Using do Loops* do loop is similar to the while loop, except that the expression is not evaluated until after the do loop's code is executed* Note the use of the semicolon at the end of the while expression## Using for Loops* 2 for loops: basic for loop, enhanced for loop ( for-in, for-each)## The Basic for Loop* Useful for flow control when you already know how many times you need to execute the statements in the loop's block* for loop declaration has 3 main parts:    * Declaration and initialization of variables    * The boolean expression (only one test expression)    * The iteration expression* Evaluating the iteration expression and then evaluating the conditional expression are always the last tow things that happen in a for loop## Basic for Loop: for Loop Issues* None of the three sections of the for declaration are required## The Enhanced for Loop (for Arrays)* for ( declaration: expression )* **declaration**: the newly declared block variable, of a type compatible with the elements of the array* **expression**: this must evaluate to the array you want to loop through## Using break and continue* continue must be inside a loop; break must be inside a loop or switch statement* break cause the program to stop execution of the innermost loop and start processing the next line of code after the block* continue cause only the current iteration of the innermost loop to cease and the next iteration of the same loop to start if the condition of the loop is met## Unlabeled Statements* Both the break statement and the continue statement can be unlabeled or labeled## Labeled Statements* A label statement must be placed just before the statement being labeled, and it consists of a valid identifier that ends with a colon (:)## Handling Exceptions* The exception may be a Runtime Exception, a Checked Exception, or an Error## Catching an Exception Using try and catch* exception = exceptional condition* try is used to define a block of code in which exceptions may occur## Using finally* finally block encloses code that is always executed at some point after the try block, whether an exception was thrown or not* Even if there is a return statement in the try block, the finally block executes right after the return statement is encountered, and before the return execute* It is illegal to use a try clause without either a catch clause or a finally clause* Any catch clauses must immediately follow the try block## Propagating Uncaught Exceptions* If a method doesn't provide a catch clause for a particular exception, that method is said to be “ducking” the exception## Exception Hierarchy* Exception, Error, RuntimeException and Throwable types can all be thrown using the throw keyword, and can all be caught## Handling an Entire Class Hierarchy of Exceptions* If the class in the catch clause does have sub-classes, any exception object that sub-classes the specified class will be caught as well* By specifying an exception class's super-class in your catch clause, you're discarding valuable information about the exception## Exception Matching* The handlers of the most specific exceptions must always be placed above those for more general exceptions* If one Exception class is not a subtype or super-type of the other, then the order in which they catch clauses are placed doesn't matter## Exception Declaration and the Public Interface* The throws keyword is used to declare the exceptions that a method can throw* Each method must either handle all checked exceptions by supplying a catch clause or lets each unhandled exception as a thrown exception* An object of type RuntimeException may be thrown from any method without being specified as part of the method's public interface* RuntimeException, Error, and all of their subtypes are unchecked exceptions and unchecked exceptions do not have to be specified or handled* When an object of a subtype of Exception is thrown, it must be handle or declared## Rethrowing the Same Exception* Rethrown Exception in catch with throw## Common Exceptions and Errors* Where Exception Come From:    * JVM exception    * Programmatic exceptions## JVM Thrown Exceptions* Only the JVM knows when an exception or error occurs, and the JVM will be the source of this error (example: NullPointerException, StackOverflowError...)## Programmatically thrown exceptions* Created by an application and/or API developer## A Summary of the Exam's Exceptions and Errors* ArrayIndexOutOfBoundsException    : by JVM* ClassCastException			    : by JVM* IllegalArgumentException			: Programmatically* IllegalStateException			    : Programmatically* NullPointerException			    : by JVM* NumberFormatException			    : Programmatically* AssertionError				    : Programmatically* ExceptionInInitializerError		: by JVM* StackOverflowError				: by JVM* NoClassDefFoundError			    : by JVM## Assertions Overview* Assertions are typically enabled when an application is being tested and debugged, but disabled when the application is deployed## Assertion Expression Rules* The first expression must always result in a boolean value* The second expression ca be anything that results in a value ( will be converted to a String representation)## Compiling Assertion-Aware Code* Use old compiler version: javac -source 1.3 OldCode.java* To use assert as an identifier, you MUST compile using -source 1.3## Enable Assertions at Runtime* java -ea TestClass* java -enableassertions TestClass## Disabling Assertions at Runtime* java -da TestClass* java -disableassertions TestClass## Selective Enabling and Disabling* With no arguments: enables or disables assertions in all classes, except for the system class* With a package name: enables and disables assertions in the package specified and any packages below this package in the same directory hierarchy* With a class name: enables or disables assertions in the class specified* java -ea -da:com.abc.Foo // disable assertion for class com.abc.Foo* java -ea -da:com.foo...	// disable assertion for packages com.foo and any of its sub-packages* java -dsa			// disable assertions in system classes## Using Assertions Appropriately* Don't use assertions to validate arguments to a public method* Do use assertions to validate arguments to a private method* Don't use assertions to validate command-line arguments* Do use assertions, even in public methods, to check for cases that you know are never, ever supposed to happens* Don't use assert expressions that can cause side effects