# SCJP 5 - Chapter 7 Generics and Collection## Overriding hashCode() and equal()* Distinguish between correct and incorrect overrides of corresponding hashCode and equals methods, and explain the difference between == and the equals method* Methods of Class Object:    * boolean equals (Object obj)    * void finalize()    * int hashCode()    * final void notify()    * final void notifyAll()    * final void wait()    * String toString()## Overriding equals()* == evaluates to true only when both references refer to the same object (because == simply looks at the bits in the variable, and they're either identical or not)* String and Wrapper classes have overridden the equals() method## What It Mean If You Don't Override equals()* If you don't override the class's equals() method, you won't be able to use those objects as a key in a hashtable and you won't get accurate Sets* equals() in Object uses only the == operator for comparisons## Implementing an equals() Method* Test instanceof && (Cast)* equals(), hashCode(), toString() are all public## The equals() Contract* Reflexive* Symmetric* Transitive* Consistent## Overriding hashCode()* Used to determine how the object should be stored in the collection, and to help locate the object in the collection## Understanding Hashcodes* hashcode tells which bucket to go into not how to locate the name once we're in that bucket## Implementing hashCode()* Follow Java contract, use the same instance variables in equals(): two equal objects have equal hashcodes## The hashCode() Contract* hashCode() return consistently return the same integer* 2 Objects are equal according to the equals(Object) then hashCode() must produce the same integer result* It is NOT require that if two object are unequal according to the equals(Object) then hashCode() must produce distinct integer results* transient variables can really mess with your equals() and hashCode() implementations. Keep variable non-transient or if they must be marked transient, don't use them to determine hashcode or equality## Collections## So What Do You Do with a Collection?* Add objects* Remove objects* Find out if an object is in the collection* Retrieve an object* Iterate through the collection## Key Interfaces and Classes of the Collections Framework* 7 Core interfaces:    * Collection    Set SortedSet    * List		    Map SortedMap    * Queue* 13 Core Concrete implementation classes:    * Maps 	: HashMap, Hashtable, TreeMap, LinkedHashMap    * Sets 	: HashSet, LinkedHashSet, TreeSet    * Lists	: ArrayList, Vector, LinkedList    * Queue: PriorityQueue    * Utilities: Collections, Arrays* collection (lowercase c): represents any of the data structures in which objects are stored and iterated over* Collection (capital C), the java.util.Collection interface from which Set, List, and Queue extend* Collections (capital C and ends with s) is the java.util.Collections class that holds a pile of static utility methods for use with collections* Collections come in 4 basic flavors:    * Lists: lists of things (classes that implement List)    * Sets: unique things (implement Set)    * Maps: things with a unique ID (implement Map)    * Queues: things arranged by the order in which they are to be processed* There are sub-flavors within those 4 flavors: Sorted, Unsorted, Ordered, Unordered* An implementation can be unsorted and unordered, ordered but unsorted, or both sorted and ordered. But can never be sorted and unordered!!!## Ordered* When a collection is ordered, it means you can iterate through the collection in a specific (not-random) order## Sorted* A sorted collection means that the order in the collection is determined according to same rule or rules, known as the sort order## List Interface* A List cares about the index, key methods: get(int index), indexOf(Object o), add(int index, Object obj)## ArrayList* ~ growable array: fast iteration and fast random access.* It is an ordered collection, but not sorted* As of version 1.4, ArrayList implements the new RandomAccess interface* Choose this over a LinkedList when you need fast iteration but aren't as likely to doing a lot of insertion and deletion## Vector* The same as an ArrayList, but Vector methods are synchronized but DEPRECATED## LinkedList* A LinkedList is ordered by index position except that the elements are doubly-linked to one another* Easy choice for implementing a stack or queue## Set Interface* A Set cares about uniqueness – it doesn't allow duplicates## HashSet* A HashSet is an unsorted, unordered Set* Use this when you want a collection with no duplicates and you don't care about order when you iterate through it## LinkedHashSet* A LinkedHashSet is an ordered version of HashSet that maintains a doubly-linked List across all elements.* Use this instead of HashSet when you care about the iteration order## TreeSet* TreeSet is one of the two sorted collections, use tree structure* When you construct a TreeSet with a constructor that lets you give the collection your own rules for what the order should be by using a Comparable or Comparator## Map Interface* A Map cares about unique identifiers* Like Sets, Maps rely on the equals() method to determine whether two keys are the same of different## HashMap* HashMap give you an unsorted, unordered Map* HashMap allows one null key and multiple null values## Hashtable* Like Vector, Hashtable has existed from prehistoric Java times* Hashtable doesn't let you have anything that's null## LinkedHashMap* Maintains insertion order (access order)## TreeMap* Sorted Map (by the natural order of the elements)## Queue Interface* FIFO (first-in, first-out)## PriorityQueue* Create a “priority-in, priority-out” queue as opposed to a typical FIFO queue## Using the Collections Framework* Use java.util## ArrayList Basics* java.util.ArrayList is one of the most commonly used of all the classes in the Collections Framework* Advantages of ArrayList over arrays:    * Can grow dynamically    * Provides more powerful insertion and search mechanisms## Autoboxing with Collections* As of Java 5, autoboxing handles the wrapping for us## Sorting Collections and Arrays* java.util.Collections.sort## Comparable Interface* Is used by Collections.sort and java.util.Arrays.sort to sort List of Object and Array of Object* Implements compareTo(anotherObject(* negative		If thisObject < anotherObject* zero			If thisObject == anotherObject* positive		If thisObject > anotherObject* sort() method uses compareTo() to determine how the List or object array should be sorted* When you override equals() you MUST take an argument of type Object, but when you override compareTo() you should take an argument of the type you're sorting## Sorting with Comparator* implement the method compare(), return an int* Comparator CANNOT be used when sorting arrays of primitives## Sorting with the Arrays Class* Arrays.sort(arrayToSort)* Arrays.sort(arrayToSort, Comparator)* Arrays.sort() methods that sort primitives ALWAYS sort based on natural order## Searching Arrays and Collections* Searches are performed using the binaraySearch()* Successful searches return the int index of the element being searched* Unsuccessful searches return an int index that represents the insertion point. The actual insertion point is represented as (-(insertion point) -1)* The collection/arrays being searched must be sorted* Use the same Comparator for sorting and searching## Converting Arrays to List to Arrays* Arrays to List : Arrays.asList()* Lists to Arrays: List.toArray(), Set.toArray()* When you use the asList() method, the array and the List become joined.When you update one of them, the other gets updated automatically* toArray() : one that returns a new Object array, and one that uses that array you send it as the destination array## Using Lists* Lists are usually used to keep things in some kind of order* Two Iterator methods:* boolean hasNext( : return true if there is at least one more element in the collection being traversed.Invoking hasNext() does NOT move you to the next element of the collection* object next(): this method returns the next object in the collection, AND moves you forward to the element after the element just returned## Using Sets* Sets are used when you don't want anny duplicates in your collection* If you attempt to add an element to a set that already exists in the set, the duplicate element will not be added, and the add() method will return false* You must use caution when using a TreeSet## Using Maps* When you use a class that implements Map, any class that you use as a part of the keys for that map must override  the hashCode() and equals() methods* Two stages of retrieval :* Use the hashcode() method to find the correct bucket* Use the equals() method to find the object in the bucket## Using the PriorityQueue Class* Basic queue structures that are FIFO, a PriorityQueue orders its elements using a user-defined priority* Queues have a few methods not found in other collection interfaces : peek(), poll(), and offer()* offer() add element to queue* peek() return the highest priority element* poll() returns the highest priority element AND removes it from the queue## Method Overview for Arrays and Collections* Key Methods in java.util.ArrayList    * static List asList(T[])		Convert an array to a List, (and bind them)    * static int binaraySearch(Object[], key)	Search a sorted array for a given value, return an index or insertion point    * static int binarySearch(T[], key, Comparator)	Search a Comparator-sorted array for a value    * static boolean equals(Objct[], Object[])		Compare two arrays to determine if their content are equal    * static boolean equals(primitive[], primitive[])    * public static void sort(Object[])    * public static void sort(primitive[])	Sort the element of an array by natural order    * public static void sort(T[], Comparator)		Sort the element of an array using a Comparator    * public static String toString(Object[])    * public static String toString(primitive[]) Create a String containning the conntents of an arrays* Key Methods in java.util.Collections    * static int binarySearch(List, key)    * static int binarySearch(List, key, Comparator)	Search a “sorted” List for given value, return an index or insertion point    * static void reverse(List)		Reverse the order of elements in a List    * static Comparator reverseOrder()    * static Comparator reverseOrder(Comparator)	Return a Comparator that sorts the reverse of the collection's current sort sequence    * static void sort(List)    * static void sort(List, Comparator)	Sort a List either by natural order of by a Comparator## Method Overview for List, Set, Map, and Queue* Key Interface Method    * boolean add(element)          L	S		Add an element    * boolean add(index, element)		L    * boolean contains(object)		L	S    * boolean containsKey(object key)				M	Search a collection for an object(or, optionally for Maps a key), return the result as a boolean    * boolean containValue(object value)			M    * object get(index)			    L			Get an object    * object get(key)						M    * int indexOf(object)			L			Get the location of an object    * Iterator iterator()			L	S		Get an iterator for List or Set    * Set keySet()						M 	Return a Set of Map's keys    * put(key, value)						M	Add a key/value    * remove(index)				    L			Remove an element    * remove(object)				L	S    * remove(key)						M    * int size()				    L	S	M	Return the number of elements    * Object[] toArray()			L	S    * T[] toArray(T[])				L	S		Return an array containing the elements of the collection## Generic Types* Before Java 5 there was no syntax for declaring a type safe collection:    * ArrayList myList = new ArrayList();    * List myList = new ArrayList();## The Legacy Way to Do Collections* A non-generic collection can hold any kind of object* Generic takes care of both ends (the putting in and getting out) by enforcing the type of your collections## Generics and Legacy Code* Add <> in BOTH the variable declaration and the constructor call## Mixing Generic and Non-generic Collections* When you are using generics, and mixing both typed and untyped code, warning matter* Compiling with warnings is NEVER considered a compilation failure* JVM has no idea about typing information, typing information does not exist at runtime.All your generic code is strictly for the compiler* Type erasure : the compiler does all of its verifications on your generic code and the strips the type information out of the class bytecode* Generics ~ strictly a compile-time protection* Arrays have BOTH compile-time protection and runtime protection* -Xlint:unchecked : compiler shows exactly which method(s) might be doing something dangerous* The moment you turn that type safe collection over to older, non-type safe code, your protection vanishes## Polymorphism and Generics* The type of the variable declaration must match the type you pass to the actual object type : List<Object> myList = new ArrayList<JButton>(); // NO!* Polymorphism applies to only the “base” type : List and ArrayList are the base type and JButton is the generic type* In Arrays, you are allowed to do this : Parent[] arrays = new Child[3];* Polymorphism does not work the same way for generics as it does with arrays## Generic Methods* The compiler and JVM behave differently for array vs generic collections* ArrayStoreException prevent you from putting the wrong type of object into an array* The generic type of an object is ALWAYS the same as the generic type declared on the reference* <? extends Animal> : i can be assigned a collection that is a subtype of List and typed for <Animal> or anything that extends Animal. I SWEAR that i will not ADD anything to the collection* extends represents BOTH subclasses and iterface implementations* There is no <? implements Serializable>* <? super ...> you can accept the type on the right-hand side of super any of its super-types => possible way to add to a collection* without super keyword, you cannot ADD anything to the list referred to as List<?>* List<? Extends Object> and List<?> are absolutely identical* Wildcards can be used only for reference declarations (including arguments, variables, return types, and so on). They can't be used a the type parameter when you create a new typed collection## Generic Declarations* <E> : element for collection* <T> : type NOT for collection## Making Your Own Generic Class* Declaring a generic type :    * as the class type    * as an instance variable type    * as an array type    * as an argument type    * as a return type* You can use more than one parametrized type in a single class* You can use a form of wildcard notation in a class definition, to specify a range (called “bounds”) for the type that can be used for the type parameter : <T extends Animal> // Use “T” instead of “?”## Creating Generic Methods* class parameter type – the type declared with the class name* You must declare the type variable BEFORE the return type of the method : public <T> void makeArrayList(T t)* You can put boundaries on the type you declare : <T extends Number>* class X { public <X> X(X x) { } }