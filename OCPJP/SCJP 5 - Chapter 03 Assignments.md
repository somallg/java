# SCJP 5 - Chapter 3 Assignment## Stack and Heap* Instance variables and objects: on the heap* Local variables: on the stack## Literal Values* Primitive literal: source code representation of the primitive data types ( 'b', 42, false, 123213.323)## Integer Literals* 3 ways to represent integer number in Java: decimal (base 10), octal (base 8) and hexadecimal (base 16)* Defined as int by default* Literals for long end in L or l## Decimal Literals* No prefix (123, 453)## Octal Literals* Use only the digits 0 to 7* With prefix: 0 in front of number ( 06, 07, 010, 011)* Can have up to 21 digits in octal number## Hexadecimal Literals* Use 16 distinct symbols ( 0 1 2 3 4 5 6 7 8 9 a b c d e f)* With prefix: 0x in front of number ( 0X0001, 0x7fffff, 0xDeadCafe)* Up to 16 digits in a hexadecimal number## Floating-Point Literals* Is a double (64 bits) by default* Use suffix F or f to assign to a variable of type float (32 bits)##Boolean Literals* Only defined as true or false:    * boolean t =true; // OK    * boolean f = 0; // compiler error!    * int x = 1; if (x) { } // compiler error!## Character Literals* Represented by a single character in single quotes:    * char a = 'a';    * char b = '@';    * Can type in the Unicode value    * char n = '\u004e';* Characters are 16-bit unsigned: range 0-65535    * char a = 0x892; // OK    * char b = 892; // OK    * char c = (char) 70000; // cast is required, out of range    * char d = (char) -98;    * char e = -29; // Error    * char f = 70000; // Error## Literal Values for String* Source code representation of a value of a String object:    * String s = "ABC DEF";    * System.out.println("ABC" + " DEF");* Can be represented as literals - i.e, typed directly into code:    * Thread t = ??? // what literal value could go here ?## Assignment Operators* Use = to assign the stuff on the right side to the variable on the left* Variable are bit holders, with designated type* For primitives, the bits represent a numeric value:    * byte i = 6; // 00000110* For objects, the bits represent the way to get to the object## Primitive Assignments* Literal integer is always implicitly an int* Result of an expression involving anything int-sized or smaller is always an int:    * byte b = 3; // OK    * byte c = 8; // OK    * byte d = b + c; // Error## Primitive Casting* Casting lets you convert primitive values from one type to another* 2 types of casting: implicit and explicit* Implicit cast:    * Don't have to write code for cast; conversion happens automatically    * Widening conversion, i.e put a smaller thing into a bigger container* Explicit:    * Have to write code for cast    * Narrowing conversion, i.e put a bigger thing into a smaller container* Example:    * int a = 100;    * long b = a; // implicit cast    * float a = 123.123f;    * int b = (int) a; // explicit cast    * long l = 130L;    * byte b = (byte) l; // -126## Assigning Floating-Point Numbers* Floating-point literal is implicitly a double (64 bits) not a float:    * float f = 32.3; // Error    * float f = (float) 32.3; // cast is required    * float g = 32.3f; // or append f    * float h = 32.3F; // same as above## Assigning a Literal That is Too Large for the Variable* byte a = 128; // Error byte can only hold up to 127* byte a = (byte) 128; // cast is required    * 128 ~ 000000000000001000000    * 1000000 ~ 01111111 + 1 = -128* byte b = 3;* b += 7; // OK* b = (byte) (b + 7); // equivalent to b +=7* Compound assignment operator (+=, -=, *=, /=) automatically add an implicit cast## Assigning One Primitive Variable to Another Primitive Variable* The contents of the right-hand variable are copied:    * int a = 6; // assign 6 for bit pattern in a    * int b = a; // copy the bit pattern in a and place the copy into b## Reference Variable Assignments* Button b = new Button();    * Make a reference variable named b of type Button    * Create a new Button object on the heap    * Assigns the object to b* Can assign to any object that is a subclass of the declared reference variable type## Variable Scope* 4 basic scope:    * Static variables have the longest scope; created when the class is created and stay as long as the class loaded in the JVM    * Instance variables: created when a new instance is created, live until the instance is removed    * Local variable: live as long as the method remains on the stack* 3 common example of scoping errors:    * Access instance variable from static method    * Access a local variable from a nested method (out of scope)    * Access block variable after the block has completed (cannot find symbol)* Shadowing occurs when two variables with different scopes share the same name## Using a Variable or Array Element That Is Uninitialized and Unassigned* Local variables: stack, temporary, automatic or method variables* Can leave a local variable uninitialized, but have to initialized to use## Primitive and Object Type Instance Variables* Instance variables (member variables): defined at the class level (i.e not with method, constructor, initializer block* Given default value each time a new instance is created:    * Object reference: null    * byte, short, int: 0    * float, double: 0.0    * boolean: false    * char: '\u0000'## Array Instance Variables* An array is an object* Array elements are always given default values:    * static int[] year = new int[100]; // all 100 integers equal 0## Local (Stack, Automatic) Primitives and Objects* Local variables: within a method and they include a method's parameters## Local Primitives* Local variables: must be initialized before use* The compiler can't always tell whether a local variable has been initialized## Local Object References* Must be initialized before use* Not given default value## Local Arrays* Must be initialized* Array elements are assigned their default values at the moment the array object is created## Assigning One Reference Variable to Another* Assign = copy the contents of a reference variable to another reference variable* When use String reference to modify a string:    * A new String is created    * The reference is assigned to the new String## Passing Variables into Methods* Difference between object reference and primitive variables## Passing Object Reference Variables* Pass an object variables = pass the object reference* Pass a copy of the reference variable## Does Java Use Pass-By-Value Semantics?* Pass-by-value = pass by variable value = pass by copy of variable value* The called method can't change the caller's variable## Array Declaration, Construction, and Initialization* Arrays are objects that store multiple variable of same type* Always be an object on heap* No such thing as a primitive array but array of primitives## Declaring an Array* Stating the type + [] (can be on the left or right of the identifier)* Not legal to specify the size of array in the declaration## Constructing One-Dimension Arrays* Must always given a size at the time of construction* Created using new: int[] i = new int[10];## Constructing Multidimensional Arrays* Only first brackets are given a size## Initializing an Array* Arrays don't hold the object but reference to the object* Need to create each element individually* Using loop to initializing array elements (example: for , for-each)## Declaring, Constructing, and Initializing on One Line* Using { } to declare, construct, and initialize* Elements are separated by comma (',')## Construction and Initializing an Anonymous Array* int[] test = new int[] { 1, 2, 3};* Create a just-in-time array to use as an argument to a method* Must not specify a size when using anonymous array## Array of Primitives* Can store any value that can be cast implicitly to the declared type of the array:    * int[] i = new int[5];    * byte b = 4;    * char c  = 'c';    * short s = 7;    * long l = 10L;    * i[0] = b; // OK    * i[1] = c; // OK    * i[2] = s; // OK    * i[3] = l; // Error!## Arrays of Object References* Can store subclass of the declared type* If the array is declared as interface type, the arrays can store any instance of the class that implements the declared interface* Any object that passes the “IS-A” test for the declared array type, can be assigned to an element of that array## Array Reference Assignments for One-Dimension Arrays* An int[] array can only assign to int[]* If A IS-A B so A[] array can assign to B[] array:    * Car[] cars;    * Honda[] honda = new Honda[5];    * cars = honda ; // OK because Honda IS-A Car    * Beer[] beers = new Beer[99];    * cars = beers; // NOT OK\* Same rule apply for interface## Array Reference Assignments for Multidimensional Arrays* 2 arrays must have the same dimension## Initialization Blocks* 3 place can put operations: methods, constructors, initialization blocks* static initialization block run once when the class is first loaded* non-static initialization block run every time a new instance is created## Using Wrapper Classes and Boxing* Provide a mechanism to “wrap” primitive values in an object so that the primitives can be used in activities reserved for objects* Provide utility functions for primitives: conversion from/to String, convert to another base## Creating Wrapper Object* 3 most common approaches for creating wrapper objects* Wrapper objects are immutables## The Wrapper Constructors* All of the wrapper classes except Character provide 2 constructors: one takes a primitive and one that takes a String representation* Character has only one constructor, which takes a char as an argument* primitive xxxValue()          - to convert a Wrapper to a primitive* primitive parseXXX(String)    - to convert a String to a primitive* Wrapper valueOf(String)       - to convert a String to a Wrapper## Autoboxing* From Java 5* Wrapper with the same small values ( lower than 127), will be ==, larger values will not be ==* In order to save memory, 2 instances of the following wrapper objects will always be == when their primitive values are the same:    * Boolean    * Byte    * Character from \u0000 to \u007f (127)    * Short and Integer from -128 to 127## Overloading Made Hard – Method Matching* Widening* Autoboxing* Var-args## Rules For Overloading* Primitive widening uses the “smallest” method argument possible* Used individually, boxing and var-args are compatible with overloading* You CANNOT widen from one wrapper to another (IS-A fails)* You CANNOT widen and the box (An int can't become a Long)* You can box and then widen (An int can become Object, via Integer)* You can combine var-args with either widening or boxing## Garbage Collection* Memory leak: memory that cannot be reclaimed* In Java, GC provides automated memory management* The purpose of GC is to delete objects that can't be reached* An object is eligible when no live thread can reach it* java -Xmx5g to increase heap memory* finalize() method is guaranteed to run once and only once before the GC deletes the object## Writing Code That Explicitly Makes Objects Eligible for Collection* Nulling a Reference* Reassigning a Reference* Isolating a Reference## Forcing Garbage Collection* You CANNOT force garbage collection* Make a request with: System.gc()